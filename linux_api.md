# 1. Введение

Под термином **операционная система** скрывается 2 определения:

+ *в широком смысле* - весь пакет программ, включающий как функционал по управлению ресурсами компьютера, так и сопроводительные стандартные средства: интерпретатор командной строки, графический интерфейс, утилиты и редакторы;
+ *в узком смысле* - только набор основных модулей, управляющих ресурсами компьютера (оперативная память, хранилища, сеть, процессорное время) и занимающихся их распределением.

Для второго определения также используется термин **ядро (kernel)** операционной системы. У работающей операционной системы имеется всего *одно ядро*. *Ядро* выполняет следующие функции:

+ **управление процессами** - ядро выполняет загрузку программ с диска в оперативную память, запуск их выполнения на процессоре, а также финальное освобождение занимаемых ими ресурсов. Запущенный экземпляр программы называют **процессом**. Помимо *создания и завершения процессов* ядро осуществляет их *диспетчеризацию* - контроль доступа к ограниченному объему общих резделяемых ресурсов компьютера и ОС. Linux является *многозадачной ОС с вытеснением* - одновременно могут выполняться несколько процессов, а их менеджментом занимается *диспетчер процессов ядра*;
+ **управление памятью** - Linux применяет технологию управления **виртуальной памятью**, которая позволяет изолировать процессы и закрыть им доступ к чужим данным, а также повысить эффективность использования имеющегося объема *физической памяти* посредством необходимости хранить в текущий момент времени только реально требуемую для выполнения часть данных процесса - в результате в память одновременно может быть загружено большее число программ;
+ **управление устройствами** - ядро предоставляет процессам программные интерфейсы доступа ко всем подключенным периферийным устройствам: устройствам ввода и вывода, накопителям, всевозможным картам расширения, последовательному порту. Также ядро предоставляет унифицированный интерфейс **виртуальной файловой системы**, обеспечивающий единообразный способ обращения к данным на накопителях различной архитектуры;
+ **управление сетью** - ядро включает в себя реализацию стека протоколов TCP/IP и обеспечивает выход в сеть через *интерфейс сокетов*;
+ **управление пользователями** - ядро предоставляет каждому зарегистрированному пользователю собственное независимое рабочее пространство, а также контролирует соблюдение им *прав доступа* к ресурсам ОС и информации других пользователей.
+ **предоставление API ядра** - все описанные выше, а также другие интерфейсы, предоставляемые ядром, объединены в общий программный интерфейс **системных вызовов** - своеобразных точек входа в ядро, через которые процесс может запросить у операционной системы выполнение требуемых ему задач.

**Оболочка (shell)** - программа, осуществляющая чтение *пользовательских команд* и использующая функционал ядра для их выполнения. Оболочка НЕ является частью ядра и разрабатывается отдельно - существует множество различных интерпретаторов команд: *sh, csh, ksh, bash, zsh*. *Оболочкой входа в систему* называют процесс, создаваемый для запуска программы оболочки при первом входе пользователя в систему.

**Системный вызов** - программная точка входа в ядро, позволяющая процессу запрашивать у операционной системы выполнения желаемых действий. Совокупность системных вызовов, реализованных на языке C, образуют *API операционной системы*. При выполнении системный вызов переводит процессор из **пользовательского режима** в **режим ядра**, который открывает ему доступ к *пространству памяти ядра*, содержащему служебные структуры данных операционной системы, а также позволяет вызывать защищенные инструкции (обращение к устройствам, управление памятью, ввод-вывод на устройствах). Каждый системный вызов идентифицируется по *уникальному номеру* и имеет строго определенный набор аргументов.

Выполнение *системного вызова* происходит следующим образом:

1. Прикладная программа инициирует системный вызов, вызвав *функцию-оболочку* из *стандартной библиотеки C*;
2. Функция-оболочка валидирует переданные ей *аргументы системного вызова*, а затем копирует их со своего *стека* в набор регистров процессора, где ожидает их появления ядро;
3. Функция-оболочка помещает *номер системного вызова* в регистр `eax`;
4. Функция-оболочка выполняет *машинную инструкцию системного прерывания* `int 0x80`, переключающую процессор в *режим ядра* и заставляющую его начать выполнять соответствующий *обработчик прерывания*. Современные архитектуры процессоров предоставляют специальную инструкцию `sysenter`, реализующую данный функционал более эффективным способом;
5. Ядро выполняет *обработчик прерывания* `system_call()`, который:
   1. сохраняет текущие значения регистров процессора в *стеке ядра*;
   2. вызывает *функцию обслуживания* переданного *номера системного вызова* `sys_ИМЯ_ВЫЗОВА()`, которая решает требуемую задачу, а затем возвращает *код возврата*;
   3. восстанавливает со *стека ядра* значения регистров процессора и помещает *возвращаемое значение* в *стек прикладной программы*;
   4. передаёт управление функции-оболочке, переводя процессор обратно в *пользовательский режим*;
6. Если возвращенное *обработчиком прерывания* значение свидетельствует об ошибке, то оно помещается в глобальную переменную `errno`;
7. Функция-оболочка завершается, возвращая прикладной программе значение, которое указывает на успех (*неотрицательное число*) или неудачу (*отрицательное число*) системного вызова.

Выполнение любого системного вызова происходит **атомарно**! Ядро гарантирует, что совершаемая им последовательность действий будет представлять собой единую неделимую операцию, которая не может быть прервана другим процессом или *потоком* - системный вызов либо успешно завершается, либо возвращает ошибку.

Помимо непосредственных функций-оболочек *стандартная библиотека С* может предоставлять *библиотечные функции*, зачастую скрывающие системный вызов за более удобным интерфейсом или вообще его не использующие, если это позволяется их решаемой задачей. Очевидно, что совершение системного вызова сопровождается существенными издержками, превышающими затраты на обычный вызов функции в пользовательском пространстве.

Текущую версию *стандартной библиотеки С* можно узнать, выполнив файл библиотеки в командной строке или в программе вызвав функцию `gnu_get_libc_version()`.

# 2. Пользователи и группы

Linux является *многопользовательской* операционной системой, поддерживающей наличие множества учетных записей со своим собственным рабочим пространством. Каждый пользователь обладает уникальным **именем** для входа в систему и связанным с ним числовым идентификатором **User ID (UID)**. Привилегированный пользователь (**cуперпользователь**), игнорирующий проверки прав доступа, имеет имя `root` и `UID = 0`. Пользователи могут объединяться в группы, также обладающие уникальным именем и идентификатором **Group ID (GID)**. Создаваемая для *суперпользователя* группа имеет имя `root` и `GID = 0`.

Информация о всех *пользователях* системы хранится в **файле паролей** `/etc/passwd`, содержащем для каждого пользователя по одной строке со следующим списком полей:

`mtk:x:1000:100:Michael Kerrisk:/home/mtk:/bin/bash`

+ *имя пользователя*;
+ *зашифрованный пароль* - единственными действительными значениями данного поля являются либо *хэш пароля* (формат определяется алгоритмом шифрования), либо *пустая строка* (если для входа пользователя не требуется пароль); при использовании **теневого файла паролей** `/etc/shadow` значение данной строки игнорируется (обычно в этом случае она содержит символ `x`);
+ *UID* - уникальный положительный целочисленный идентификатор пользователя;
+ *GID* - идентификатор первой из групп, членом которых является пользователь;
+ *комментарий* - текстовая строка с произвольными сведениями о пользователе;
+ *домашний каталог* - исходный каталог при входе пользователя в систему; передаётся в переменную окружения `HOME`;
+ *оболочка входа в систему* - путевое имя файла программы используемой оболочки, которая получает управление после входа пользователя в систему; передается в переменную окружения `SHELL`.

Обычно имя пользователя и его идентификатор связаны взаимно однозначно, однако система не запрещает *файлу паролей* соотносить *несколько имен* пользователей с *одним и тем же UID* - это позволяет получать доступ к одному ресурсу (ассоциированному как раз с UID) под разными именами и паролями.

Поскольку различные непривилегированные утилиты обращаются к *файлу паролей*, то конфиденциальная информация каждого пользователя была перенесена в отдельный **теневой файл паролей** `/etc/shadow`:

`mtk:$type$salt$hash:18727:0:99999:7:::`

+ *имя пользователя*;
+ *зашифрованный пароль* - данное поле имеет формат `$type$salt$hash` и содежрит *хэш пароля*, полученный одним из возможных алгоритмов шифрования (MD5, Blowfish, SHA и прочие); специальными значениями являются: `*` - запись пользователя не предназначена для входа, `!` - вход по паролю заблокирован (но возможны другие способы), `!!` - пароль пользователя не был установлен;
+ *время последнего изменения пароля* - измеряется в днях, прошедших с *Epoch* (1 января 1970);
+ *минимальный срок действия пароля* - число дней, которое должно пройти перед тем, как пароль снова сможет быть изменен;
+ *максимальный срок действия пароля* - число дней, после истечения которого пароль должен быть изменен;
+ *период предупреждения* - число дней до окончания срока действия пароля, в течение которого пользователь будет получать предупреждения о необходимости смены пароля;
+ *период бездействия* - число дней после окончания срока действия пароля, по истечении которого учетная запись пользователя будет отключена;
+ *дата отключения учетной записи* - измеряется в днях, прошедших с *Epoch*;
+ *резерв* - всегда пусто.

Информация о всех *группах* системы хранится в **файле групп** `/etc/group`:

`jambit:x:106:claus,frank,markus`

+ *имя группы*
+ *зашифрованный пароль группы* - необязательный пароль группы в настоящее время используется крайне редко; содержимое аналогично соответствующему полю из файла паролей; при использовании **теневого файла групп** `/etc/gshadow` значение данной строки игнорируется (обычно в этом случае она содержит символ `x`);
+ *GID* - уникальный положительный целочисленный идентификатор группы;
+ *список членов* - имена всех пользователей, входящих в данную группу.

*Файлу групп* также не запрещается соотносить *несколько имен* групп с *одним и тем же GID*.

## 2.1. Извлечение информации из файла паролей

Одна запись файла паролей `/etc/passwd` представляется следующей структурой (поля приводятся в порядке следования их описаний выше):

```C
struct passwd 
{
    char *pw_name;
    char *pw_passwd;
    uid_t pw_uid;
    gid_t pw_gid;
    char *pw_gecos;
    char *pw_dir;
    char *pw_shell;
};
```

---

```C
struct passwd *getpwnam(const char *name);
struct passwd *getpwuid(uid_t uid);
```

Извлекают соответствующую запись из файла паролей по имени пользователя или его UID.

Данные функции являются **нереентерабельными**, поскольку результатом их вызова является указатель на *статически выделенную память*! Реентерабельные аналоги: `getpwnam_r()` и `getpwuid_r()`.

---

```C
struct passwd *getpwent(void);
void setpwent(void);
void endpwent(void);
```

Выполняют последовательный вывод всего содержимого файла паролей:

+ `getpwent()` - последовательно возвращает записи из файла паролей, автоматически открывая его при первом вызове; **нереентерабельна**;
+ `setpwent()` - cбрасывает позицию в открытом файле паролей на начало;
+ `endpwent()` - закрывает файл паролей.

## 2.2. Извлечение информации из теневого файла паролей

Одна запись теневого файла паролей `/etc/shadow` представляется следующей структурой (поля приводятся в порядке следования их описаний выше):

```C
struct spwd
{
    char *sp_namp;
    char *sp_pwdp;
    long sp_lstchg;
    long sp_min;
    long sp_max;
    long sp_warn;
    long sp_inact;
    long sp_expire;
    unsigned long sp_flag;
};
```

---

```C
struct spwd *getspnam(const char *name);
```

Извлекает соответствующую запись из теневого файла паролей по имени пользователя.

Данная функция являются **нереентерабельной**! Реентерабельный аналог: `getspnam_r()`.

---

Выполняют последовательный вывод всего содержимого теневого файла паролей:

```C
struct spwd *getspent(void);
void setspent(void);
void endspent(void);
```

+ `getspent()` - последовательно возвращает записи из теневого файла паролей, автоматически открывая его при первом вызове; **нереентерабельна**;
+ `setspent()` - cбрасывает позицию в открытом теневом файле паролей на начало;
+ `endspent()` - закрывает теневой файл паролей.

## 2.3. Извлечение информации из файла групп

Одна запись файла групп `/etc/group` представляется следующей структурой (поля приводятся в порядке следования их описаний выше):

```C
struct group
{
    char *gr_name;
    char *gr_passwd;
    gid_t gr_gid;
    char **gr_mem;
};
```

---

```C
struct group *getgrnam(const char *name);
struct group *getgrgid(gid_t gid);
```

Извлекают соответствующую запись из файла групп по имени группы или её GID.

Данные функции являются **нереентерабельными**! Реентерабельные аналоги: `getgrnam_r()` и `getgrgid_r()`.

---

```C
struct group *getgrent(void);
void setgrent(void);
void endgrent(void);
```

Выполняют последовательный вывод всего содержимого файла групп:

+ `getgrent()` - последовательно возвращает записи из файла групп, автоматически открывая его при первом вызове; **нереентерабельна**;
+ `setgrent()` - cбрасывает позицию в открытом файле групп на начало;
+ `endgrent()` - закрывает файл групп.

### 2.3.1. Шифрование пароля

```C
char *getpass(const char *prompt);
```

Выводит в терминал указанную строку приглашения `prompt` и затем считывает и возвращает в *статически* выделенной строке *незашифрованный* пароль. На время ввода пароля отключает отображение символов в терминале. **Нереентерабельна**.

---

```C
char *crypt(const char *key, const char *salt);
```

Возвращает *статически* выделенную строку, содержащую результат применения к паролю `key` и аргументу `salt` используемого алгоритма шифрования. **Нереентерабельна**.

# 3. Системные ограничения и возможности





# 4. Файловый ввод-вывод

**Файл** - это поток байтов, представляющих собой данные. В операционной системе с файлом ассоциированы 3 сущности:

1. **таблица индексных дескрипторов** файловой системы;
2. общесистемная **таблица открытых файлов**;
3. **таблица файловых дескрипторов** каждого процесса.

![таблицы файловых дескрипторов](images/img-2.png)

**Дескриптор файла** - это целочисленный идентификатор, присваиваемый файлу при его *открытии* процессом. Чтобы совершить над файлом большинство действий, в первую очередь необходимо получить его дескриптор, а уже затем передать его в качестве аргумента в системный вызов.

Для каждого процесса ядро поддерживает его *собственную* **таблицу дескрипторов файлов**. Её записи содержат:

+ *набор флагов* данного дескриптора, единственным возможным членом которого является флаг *close-on-exec* `FD_CLOEXEC`;
+ ссылку на соответствующую *дескрипцию открытого файла*.

На *общесистемном* уровне ядро поддерживает существующую в единственном экземпляре **таблицу открытых файлов**. Её записи, называемые **дескрипциями открытых файлов**, содержат следующую информацию о файле, над которым было произведено *открытие*:

+ текущее **файловое смещение**, также называемое *файловым указателем*, которое определяет позицию в файле, с которой будет выполняться следующая операция чтения/записи;
+ *флаги состояния* файла;
+ *режим доступа* к файлу;
+ установки механизма *ввода-вывода на основе сигналов*;
+ ссылка на соответствующий *индексный дескриптор* файла;

Само понятие файла как объединения взаимосвязанных данных вводит *файловая система*, которая для обеспечения своих функций (хранение информации) поддерживает реестр, называемый **таблицей индексных дескрипторов**. Её записи содержат:

+ тип файла;
+ *права доступа* к файлу со стороны пользователей ОС;
+ список *блокировок*, удерживаемых на файле;
+ всевозможные свойства файла: размер, метки времени и прочие.

Отдельная *дескрипция файла* создаётся при каждом его *открытии* с помощью системного вызова `open()`. Дескрипция, в свою очередь, порождает связанный с ней единственный *дескриптор файла*. Дополнительные экземпляры *дескрипторов* могут быть получены *дублированием* исходного с помощью набора системных вызовов `dup()`, *наследованием* от родительского процесса или передачей через *сокет домена UNIX*. Очевидно, что все файловые дескрипторы, ссылающиеся на некую единственную дескрипцию, будут иметь доступ к одним и тем же её полям (в особенности к *смещению* и *флагам состояния*), однако каждый из них будет обладать собственным значением флага *close-on-exec*.

Номера всех файловых дескрипторов начинаются с 0 и следуют друг за другом по возрастанию, причем при создании дескриптора любым способом ему гарантированно выдается *наименьший* доступный на текущий момент номер. Любой процесс, не являющийся *демоном*, будет по умолчанию обладать набором 3 *стандартных дескрипторов*, унаследованных им от своей оболочки:

+ `STDIN_FILENO` - стандартный *ввод*, номер `0`;
+ `STDOUT_FILENO` - стандартный *вывод*, номер `1`;
+ `STDERR_FILENO` - cтандартная *ошибка*, номер `2`.

Для каждого открытого файла ядро хранит **файловое смещение (файловый указатель)**, определяющее позицию в байтах, с которой будет выполняться следующая операция ввода-вывода. При открытии файла смещение устанавливается на его начало (если явно не указано иное), а затем последовательно сдвигается каждым успешно завершенным чтением или записью. Также файловый указатель может быть перемещен на требуемую позицию явным образом, причем его новое положение может располагаться за текущим концом файла - если по такой позиции будет выполнена операция записи, то образуется **файловая дыра**. До тех пор пока файловая дыра пуста (в её пределах отсутствуют явно записанные данные), она не занимает места, и файловая система не выделяет для неё дисковые блоки. Однако с программной точки зрения дыра хранит данные, и чтение из неё будет возращать нулевые байты - это означает, что номинальный объём файла, может превышать его реальный физический размер. Механизм файловых дыр позволяет экономить дисковое пространство, занимаемое слабозаполненными (разреженными, sparce) файлами. *Файлы дампа ядра*, содержащие слепок виртуальной памяти процесса на момент его завершения, являются их харакретными представителями.

![файловая дыра](images/img-1.png)

Ядро предоставляет ряд *виртуальных каналогов* с информацией о файловых дескрипторах процессов:

+ `/proc/PID/fdinfo` - для процесса с идентификатором `PID` содержит справочные файлы (смещение, флаги и т.д.) по одному на каждый из его файловых дескрипторов;
+ `/proc/self/fdinfo` - предоставляемая каждому процессу ядром *символьная ссылка* на его собственный каталог `fdinfo`;
+ `/proc/PID/fd` - для процесса с идентификатором `PID` содержит *символьные ссылки* на файлы, открытые им через каждый из своих файловых дескрипторов. В Linux открытие файла из данного каталога приводит к *повторному открытию* (с созданием новой *дескрипции*) исходного файла. Зачастую файлы из данного каталога используются для передачи стандартных ввода/ввывода процесса, не имеющих существующей в файловой системе сущности, в утилиты командной строки, принимающие в качестве аргументов путевые имена файлов;
+ `/proc/self/fd` - предоставляемая каждому процессу ядром *символьная ссылка* на его собственный каталог `fd`;
+ `/dev/fd` - аналог описанной выше *символьной ссылки* на каталог `fd` процесса.

## 4.1. Универсальный интерфейс ввода-вывода

Linux предоставляет **универсальную модель ввода-вывода** - для выполнения чтения/записи во *все типы файлов*, включая устройства, терминалы и IPC, применяется интерфейс системных вызовов `open/read/write/close`. Данный механизм обеспечивается тем, что каждая файловая система или драйвер устройства самостоятельно реализуют требуемый от них набор операций ввода/вывода, а детали их обработки ядро скрывает внутри себя - в результате при написании прикладных программ можно игнорировать специфику устройства.

---

```C
int open(
    const char *pathname, 
    int flags, ... 
    /* mode_t mode */);
```

Открывает файл, идентифицированный путевым именем в аргументе `pathname`, и возвращает его *файловый дескриптор*. Гарантируется, что созданный файловый дескриптор будет иметь наименьший неиспользуемый номер. Если имя файла содержит *символьную ссылку*, то она разыменовывается.

Если файл не существует, то он может быть автоматически создан при открытии (это определяется битовой маской флагов). В этом случае аргумент `mode` применяется для установки *прав доступа* к файлу со стороны *владельца*, *группа* и *других пользователей* (возможные значения описываются позднее) - в противном случае он может быть опущен. Фактически установленный набор прав определяется комбинацией значений *аргумента mode*, ***маски процесса umask*** и ***списка контроля доступа (ACL)** по умолчанию  родительского каталога*.

Аргумент `flags` содержит битовую маску режима доступа к файлу, включающую следующие группы флагов:

+ *Флаги режима доступа к файлу* - впоследствии могут быть извлечены:
  + `O_RDONLY` - открыть файл только для чтения;
  + `O_WRONLY` - открыть файл только для записи;
  + `O_RDWR` - открыть файл для чтения и записи;
+ *Флаги создания файла* - управляют поведением вызова; НЕ могут быть извлечены или изменены;
  + `O_CLOEXEC` - установить флаг файлового дескриптора close-on-exec `FD_CLOEXEC`;
  + `O_CREAT` - создать новый файл, если он не существует; требует обязательного наличия аргумента вызова `mode`;
  + `O_DIRECTORY` - путевое имя `pathname` должно указывать на *каталог*;
  + `O_EXCL` - указывается совместно с `O_CREAT`; создать новый файл либо вернуть ошибку, если он уже существует (*эксклюзивное создание файла*);
  + `O_LARGEFILE` - используется в 32-разрядных системах для открытия больших файлов, по размеру превышающих 2 Гбайта;
  + `O_NOCTTY` - запретить терминалу под путевым именем `pathname` становиться **управляющим терминалом** данного процесса;
  + `O_NOFOLLOW` - не разыменовывать символьные ссылки;
  + `O_TRUNC` - очистить открываемый файл;
+ *Флаги состояния файла* - впоследствии могут извлечены и изменены:
  + `O_APPEND` - перевести *указатель файла (смещение)* в его конец;
  + `O_NONBLOCK` - открыть файл в *неблокируемом режиме*: если операция ввода-вывода над файлом не может *мгновенно* завершиться *полностью*, то она либо целиком отменяется, возвращая синонимичные значения `EAGAIN` или `EWOULDBLOCK` в переменной `errno`, либо выполняется частично, возвращая реально обработанное количество байт;
  + `O_ASYNC` - часть механизма *ввода-вывода на основе сигналов*; отправлять процессу *сигнал*, когда указанный дескриптор становится доступен для выполнения ввода-вывода; может быть установлен только вызовом `fcntl(F_SETFL)`;
  + `O_DIRECT` - выполнять операции ввода-вывода в обход *дисковых буферов ядра*;
  + `O_SYNC` - выполнять операции ввода-вывода в *синхронном режиме*;
  + `O_DSYNC` - выполнять операции синхронного ввода-вывода с *сохранением целостности данных*;
  + `O_NOATIME` - не обновлять время последнего обращения к файлу при его чтении; *действующий UID* процесса должен соответствовать владельцу файла, либо процесс должен быть *привилегированным* (`CAP_FOWNER`).

---

```C
ssize_t read(
    int fd, 
    void *buffer, 
    size_t count);
```

Считывает из указанного фала максимально `count` байт в заранее выделенный буфер `buffer`. В случае успеха возвращает число *реально прочитанных* байт, которое может оказаться меньше указанного максимального. Попытка чтения за текущим концом файла вернёт 0 байт - данные отсутствуют.

---

```C
ssize_t write(
    int fd, 
    const void *buffer, 
    size_t count);
```

Записывает в указанный файл максимально `count` байт, хранящихся в буфере `buffer`. В случае успеха возвращает число *реально записанных* байт, которое может оказаться меньше указанного максимального. Завершение данного вызова не гарантирует перенос данных на устройство, поскольку ядро выполняет буферизацию дискового ввода-вывода.

---

```C
off_t lseek(int fd, off_t offset, int whence);
```

Сдвигает файловый указатель на `offset` байт относительно позиции `whence`. В случае успеха возвращает новое полученное значение файлового смещения.

Аргумент `whence` принимает следующие значения:

+ `SEEK_SET` - отправной точкой служит начало файла (нулевая позиция);
+ `SEEK_CUR` - отправной точкой служит текущее положение файлового указателя;
+ `SEEK_END` - отправной точкой служит позиция, *следующая за последним байтом файла*;

Аргумент `offset` является целым числом со знаком: нулевое значение просто вернет текущее смещение, а отрицательное заставит указатель передвинуться в противоположном направлении, однако *выходить за начало файла ЗАПРЕЩЕНО*.

Зачастую данный вызов применяется к обыкновенным файлам данных на диске - он не может быть вызван над *FIFO*, *сокетом* и *терминалом*. Файловое смещение - это сущность ядра, и его изменение не требует физического доступа к устройству хранения.

---

```C
int close(int fd);
```

Закрывает открытый файловый дескриптор, высвобождая его для повторного использования процессом. Завершение процесса также приводит к автоматическому закрытию всех его файловых дескрипторов.

---

```C
int truncate(const char *pathname, off_t length);

int ftruncate(int fd, off_t length);
```

Устанавливают для файла, заданного через путевое имя `pathname` или дескриптор `fd`, новый размер `length`. Если файл *урезается*, то избыточные данные теряются. Если файл *увеличивается* в размере, то добавляются нулевые байты, либо образуется файловая дыра. При выполнении данного вызова к файлу применяются стандартные проверки режима и прав доступа.

---

```C
int fcntl(int fd, int cmd, ...);
```

Позволяет извлечь либо установить флаги *режима доступа* и *состояния* указанного файлового дескриптора. Аргумента `cmd` определяет выполняемое действие и принимает значения `F_GETFL` или `F_SETFL`. При установке флага(ов) вызов принимает дополнительный содержащий их параметр.

---

```C
int ioctl(int fd, int request, ... /* argp */);
```

Вызов общего назначения, позволяющий выполнять над указанным файлом или устройством операции, выходящие за пределы описанной универсальной модели. Аргумент `request`, обозначающий совершаемую операцию, обычно сопровождается набором её входных параметров `argp` любого требуемого типа.

## 4.2. Дополнительные операции ввода-вывода

```C
ssize_t pread(
    int fd, 
    void *buf, 
    size_t count, 
    off_t offset);

ssize_t pwrite(
    int fd, 
    const void *buf, 
    size_t count, 
    off_t offset);
```

Являются аналогами стандартных вызовов, однако осуществляют ввод-вывод с заданного смещения `offset` от начала файла, а не с текущей позиции файлового указателя. *НЕ изменяют* значение *файлового смещения*, содержащее в общесистемной дескрипции файла. Тип файла, над которым выполняются данные вызовы, должен поддерживать произвольную установку файлового смещения.

---

```C
ssize_t readv(
    int fd, 
    const struct iovec *iov, 
    int iovcnt);

ssize_t writev(
    int fd, 
    const struct iovec *iov, 
    int iovcnt);
```

Осуществляют *фрагментированный ввод-вывод (scatter-gather IO)*: считывают или записывают непрерывную последовательность байтов файла в `iovcnt` буферов в порядке их следования в наборе `iov`. Поскольку данные вызовы совершаются *атомарно*, то *любые* операции ввода-вывода над указанным файлом в других процессах или потоках не могут нарушить непрерывность обрабатываемой последовательности данных.

---

```C
ssize_t preadv(
    int fd, 
    const struct iovec *iov, 
    int iovcnt, 
    off_t offset);

ssize_t pwritev(
    int fd, 
    const struct iovec *iov, 
    int iovcnt, 
    off_t offset);
```

Фрагментированный ввод-вывод по заданному смещению - являются комбинацией описанных выше вызовов.

## 4.3. Дублирование файловых дескрипторов

```C
int dup(int oldfd);
```

Создает дубликат исходного дескриптора `oldfd`, указывающий на ту же дескрипцию файла в общесистемной таблице.

---

```C
int dup2(int oldfd, int newfd);
```

Создает дубликат исходного дескриптора `oldfd`, указывающий на ту же дескрипцию файла в общесистемной таблице, присваивая ему номер дескриптора `newfd`. Если `newfd` уже существует, то сначала он будет **закрыт**, причем закрытие и повторное открытие будут выполнены *атомарно*. Если в аргументы вызова передан один и тот же дескриптор, то никаких действий не совершается.

---

```C
int dup3(int oldfd, int newfd, int flags);
```

Аналог вызова `dup2()`, дополнительно позволяющий с помощью значения `O_CLOEXEC` аргумента `flags` сразу установить в результирующем дескрипторе флаг close-on-exec.

## 4.4. Создание временных файлов

Если программе на время работы требуются временные файлы, которые будут уничтожены по её завершении, то она может воспользоваться набором библиотечных функций.

---

```C
int mkstemp(char *template);
```

Создаёт и открывает для чтения/записи, возвращая его дескриптор, файл, шаблон `template` путевого имени которого обязан заканчиваться символьной последовательностью `XXXXXX` - она будет автоматически заменена ядром на строку, придающую имени уникальность. Открываемый файл получает права чтения/записи для владельца, а также флаг `O_EXCL`, гарантирующий эксклюзивный доступ. Обычно сразу после создания файла его запись в файловой системе уничтожают вызовом `unlink()` - он продолжит быть доступен процессу через свой дескриптор и будет окончательно удален при его закрытии.

---

```C
FILE *tmpfile(void);
```

Создаёт и эксклюзивно (`O_EXCL`) открывает для чтения/записи временный файл с уникальным именем, возвращая его *файловый поток* библиотеки stdio языка C. При закрытии он будет автоматически удалён.

# 5. Процессы

**Программа** - файл, содержащий следующую информацию о том, как при его выполнении конструировать *процесс*:

+ **идентификатор двоичного формата** - используется ядром для верной интерпретации содержимого файла программы. Linux применяет формат исполняемых и компонуемых файлов - **Executable and Linking Format (ELF)**;
+ **машинный код** - алгоритм программы;
+ **данные** - числовые и сомвольные константы, указанные в программе при её компиляции;
+ **адрес входа в программу** - местоположение первой инструкции, с которой должно начаться выполнение программы;
+ **таблица имен и переадресации** - определяет имена и расположение функций и переменных в файле программы;
+ **информация о библиотеках и компоновщике** - набор полей, определяющий путевые имена используемых динамических библиотек и компоновщика.

**Процесс** - абстракция, являющаяся совокупностью всех ресурсов системы, выделенных ядром для выполнения данного экземпляра программы. Единственный файл программы служит для построения на его основе множества процессов. Физически *процесс* представляет собой некоторый объем оперативной памяти, содержащий в себе загруженные из файла программы машинные инструкции прикладного алгоритма и необходимые ему переменные (в *пользовательском пространстве памяти* процесса), а также инструкции кода ядра и служебные структуры данных (в *пространстве памяти ядра* процесса), управляющие функционированием данного процесса и его взаимодействием с системой и другими процессами. Инструкциям процесса (как прикладным, так и ядра) для их выполнения периодически выделяется доля времени центрального процессора. Системой накладываются ограничения на каждый тип ресурсов процесса, и она следит за соблюдением лимитов. При завершении процесса все занимаемые им ресурсы освобождаются и становятся доступными другим процессам.

Любой процесс обладает создавшим его **родительским процессом**. Корневым предком всех процессов системы является **процесс `init`**. Родителями процессов пользовательских программ являются процессы командных оболочек. Если процесс по некоторой причине **сиротеет** (его родитель полностью завершает своё выполнение), то его новым родителем напрямую становится процесс `init`.

## 5.1. Идентификаторы процесса

Каждый процесс обладает набором связанных с ним идентификаторов.

### 5.1.1. Cобственный идентификатор процесса - PID

**Process ID (PID)** - уникальный идентификатор, позволяющий однозначным образом отличить заданный процесс. Является целом положительном числом. Пользовательский процесс минимально может получить идентификатор с номером `300` - меньшие значения занимаются системными процессами. Максимально возможное значение PID в Linux определяется файлом `/proc/sys/kernel/pid_max` и на 64-х разрядной системе составляет $2^{22}$ (около 4 миллионов).

**Parent PID (PPID)** - PID родителя данного процесса.

Для процесса `init`, являющегося родителем всех процессов системы, `PID = 1`. Сам `init` не имеет родителя - его`PPID = 0`.

---

```C
pid_t getpid(void);
```

Возвращает PID процесса, выполнившего данный вызов.

---

```C
pid_t getppid(void);
```

Возвращает идентификатор родителя PPID процесса, выполнившего данный вызов.

### 5.1.2. Идентификаторы владельца процесса

Процесс хранит несколько идентификаторов, обозначающих, какому пользователю он принадлжеит:

+ **реальные (real) UID и GID** - идентификаторы пользователя и группы, которым *принадлежит процесс*. Процесс *наследует* данные идентификаторы от своего *родителя*. Процесс *оболочки входа* пользователя, являющийся родителем всех процессов прикладных программ, получает их из *файла паролей* `/etc/passwd`;
+ **действующие (effective) UID и GID** - идентификаторы пользователя и группы, реально используемые в *проверках разрешений* на доступ процесса к ресурсам ядра. Могут изменяться во время работы процесса;
+ **сохраненные (saved) set-user-ID и set-group-ID** - идентификаторы пользователя и группы процесса, содержащие значения *владельца и группы* исполняемого *файла программы*, для которого установлены **биты set-user-ID и set-group-ID**.

    Запуске файла программы с установленными *битами set-user-ID и set-group-ID* сопровождается следующей последовательностью действий:

    1. *реальные ID* процесса наследуются им от своего родителя;
    2. *действующими ID* процесса становятся владелец и группа файла;
    3. *сохраненным ID* присваиваются копии значений действующих ID.

    Далее во время работы процесс, выполняя соответствующие системные вызовы, может переключать значения своих действующих идентификаторов между реальными и сохраненными значениями.

    В терминале битовые флаги set-user-ID и set-group-ID файла программы могут быть установлены командами:

    ```bash
    $ chmod u+s program
    $ chmod g+s program
    ```

    Установленные флаги отображаются символом `S` в позициях *полномочия выполнения владельцем и группой* `-rwSrwSrwx`;
+ **идентификаторы файловой системы** - идентификаторы UID и GID, используемые при выполнении процессом *операций в файловой системе*. Существуют по историческим причинам и практически всегда *автоматически дублируют* значения *действующих идентификаторов*;
+ **дополнительные идентификаторы групп** - набор идентификаторов GID групп, в которых состоит процесс. Максимальное количество групп процесса определяется ограничением `_SC_NGROUPS_MAX`. Процесс *наследует* дополнительные групповые идентификаторы от своего *родителя*. Процесс *оболочки входа* пользователя, являющийся родителем всех процессов прикладных программ, получает их из *файла групп* `/etc/group`.

Управление идентификаторами процесса осуществляется через набор системных вызовов. При изменении идентификаторов необходимо *сначала* менять *групповые* ID, а только *затем пользовательские* ID: преждевременная смена пользователя может привести к утрате возможности установить желаемый групповой идентификатор. Привилегиями, позволяющими процессу *произвольно изменять* своего пользователя и группа, являются `CAP_SETUID` и `CAP_SETGID`.

Также все идентификаторы данного процесса могут быть просмотрены в предоставляемом ядром файле `/proc/PID/status`.

---

```C
uid_t getuid(void);
gid_t getgid(void);
```

Возвращают *реальный* идентификатор.

---

```C
uid_t geteuid(void);
gid_t getegid(void);
```

Возвращают *действующий* идентификатор.

---

```C
int getresuid(
    uid_t *ruid, 
    uid_t *euid, 
    uid_t *suid);

int getresgid(
    gid_t *rgid, 
    gid_t *egid, 
    gid_t *sgid);
```

Возвращают *реальный, действующий и сохраненный* идентификаторы.

---

```C
int setuid(uid_t uid);
int setgid(gid_t gid);
```

Изменяют идентификаторы процесса следующим образом:

+ если вызваны *обыкновенным процессом*, то изменяют только *действующий идентификатор*, причем значение аргумента должно совпадать с *реальным или сохраненным* ID;
+ если вызваны *привилегированным процессом*, то изменяют все идентификаторы - *реальный, действующий и сохраненный*; применяется для **окончательного сброса привилегий**.

---

```C
int seteuid(uid_t euid);
int setegid(gid_t egid);
```

Изменяют *действующий* идентификатор следующим образом:

+ если вызваны *обыкновенным процессом*, то значение аргумента должно совпадать с совпадать с *реальным или сохраненным* ID;
+ если вызваны *привилегированным процессом*, то аргумент может принимать любые значения; применяется для **временного сброса привилегий**, т.к. действующий ID по прежнему может быть восстановлен из реального или сохраненного.

---

```C
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);
```

Изменяют *реальный и действующий* идентификаторы следующим образом:

+ если вызваны *обыкновенным процессом*, то значение аргумента *нового реального* ID должно совпадать с *действующим* ID; значение аргумента *нового действующего* ID - c *реальным или сохраненным* ID;
+ если вызваны *привилегированным процессом*, то оба аргумента могут принимать любые значения;
+ также для *любого типа процесса* *сохраненному* ID присваивается значение *нового действующего* ID при выполнении любого условия:
  + аргумент *реального* ID не равен `-1`;
  + *новый действующий* ID отличается от *изначального реального ID*;

Если изменение какого-то идентификатора не требуется, то его аргументу присваивается значение `-1`.

---

```C
int setresuid(
    uid_t ruid, 
    uid_t euid, 
    uid_t suid);

int setresgid(
    gid_t rgid, 
    gid_t egid, 
    gid_t sgid);
```

Изменяют *реальный, действующий и сохраненный* идентификаторы следующим образом:

+ если вызваны *обыкновенным процессом*, то значением аргумента *любого нового* ID может являться *любой из текущих* ID - *реальный, действующий или сохраненный*;
+ если вызваны *привилегированным процессом*, то все аргументы могут принимать любые значения;

Если изменение какого-то идентификатора не требуется, то его аргументу присваивается значение `-1`.

---

```C
int setfsuid(uid_t fsuid);
int setfsgid(gid_t fsgid);
```

Изменяет идентификаторы *файловой системы* следующим образом:

+ если вызваны *обыкновенным процессом*, то значением аргумента может являться *любой из текущих* ID - *реальный, действующий или сохраненный*;
+ если вызваны *привилегированным процессом*, то аргумент может принимать любые значения;

---

```C
int getgroups(
    int gidsetsize, 
    gid_t grouplist[]);
```

Возвращает в заранее выделенном аргументе `grouplist` список *дополнительных групповых* идентификаторов.

---

```C
int setgroups(
    size_t gidsetsize, 
    const gid_t *grouplist);
```

Заменяет *дополнительные групповые* идентификаторы на переданный в `grouplist` набор.

---

```C
int initgroups(const char *user, gid_t group);
```

Заменяет *дополнительные групповые* идентификаторы, выполняя просмотр файла групп `/etc/group` для указанного в `user` имени пользователя и добавляя к прочитанному набору GID, переданный в аргументе `group`.

## 5.2. Модель памяти процесса

Пространоство адресов памяти, выделенной процессу, *логически* подразделяется на несколько отдельных *сегментов*:

![сегменты памяти процесса](images/img-3.png)

+ **текстовый сегмент** - машинные инструкции пользовательской программы; доступен *только для чтения*; создаётся с возможностью *совместного использования*, в результате единственный экземпляр кода программы с диска проецируется в память множества процессов;
+ **инициализированные данные** - глобальные и статические переменные, инициализированные в коде программы явным образом;
+ **неинициализированные данные** - глобальные и статические переменные *встроенных типов*, НЕ инициализированные явным образом; система автоматически заполняет данную область 0 при страте процесса;
+ **динамическая память (куча)** - область, из которой в ходе работы программы выделяется память под переменнные; верхнюю границу кучи называют *program break*;
+ **стек** - динамически увеличивающаяся и уменьшающаяся последовательность **стековых кадров (фреймов)**; каждой вызванной на данный момент *функции* соответствует собственный фрейм, содержащий её аргументы, локальные переменные, возвращаемое значение;
+ общая область для **аргументов командной строки** и **переменных окружения**.

Физически память, занимаемая инструкциями и переменными процесса, представляет собой набор блоков фиксированного размера - **страничных кадров (фреймов)**. Однако диапазон доступной процессу памяти НЕ образован реальными адресами оперативной памяти - в Linux используется **механизм управления виртуальной памятью**. Каждому процессу выделяется непрерывное, доступное только ему **виртуальное адресное пространство**, простирающееся от нулевого адреса до $2^{32}$ или $2^{64}$ (определяется разрядностью процессора и операционной системы). Выделение виртуальной памяти аналогично происходит фиксированными блоками, называемыми **страницами**. Во время своей работы процесс оперирует виртуальными адресами, однако в реальности каждая *виртуальная страница* представляется *физическим страничным кадром* - информация о соответствии хранится в  **таблице страниц процесса**, а самим отображением виртуальных адресов в реальные занимается специализированный блок центрального процессора *Paged Memory Management Unit (PMMU)*, содержащий кеш *Translation Lookaside Buffer (TLB)*, ускоряющий данную операцию.

![таблица страниц процесса](images/img-4.png)

В любой момент в *страничных кадрах* НЕ требуется наличие ВСЕХ *виртуальных страниц* процесса - реально располагающийся в оперативной памяти набор называется **резидентным набором**. Неиспользуемые страницы при исчерпании всей физической памяти могут размещаться в зарезервированной области диска - **файле подкачки**. Применение данной техники возможно благодаря тому, что программам присуще *свойство локальности* - они демонстрируют тенденцию обращаться в ближайшем будущем к тем же либо близким адресам памяти, к которым было обращение в недавнем прошлом.

Применение операционной системой механизма виртуальной памяти предоставляет следующие преимущества:

+ *процессы изолированы* друг от друга и от ядра, поскольку через таблицу страниц имеют доступ только к собственным кадрам - это не позволяет им прочитать или испортить чужие данные;
+ при необходимости процессы могут *совместно использовать* одну и ту же *физическую память*: виртуальные страницы каждого будут отображаться на одни и те же физические кадры; наиболее характерные примеры - выполнение разными процессами кода одной программы, либо явное выделение *разделяемой памяти* (средство IPC);
+ возможна реализация гибких *схем защиты памяти*, позволяющих для каждой отдельной страницы указывать список действий, которые данный процес может совершать с данным блоком памяти;
+ используемое программой *виртуальное пространство* может существенно *превышать* доступный *физический объем* - страницы будут загружаться в память и выгружаться из неё по мере необходимости; например, программа СУБД может целиком отобразить файл базы в память - так поступает *MongoDB*.

### 5.2.1. Сегмент стека

В Linux на архитектуре процессоров x86 программный **стек** располагается в верхней части памяти и растет вниз. Динамическую вершину стека называют **указателем стека**. При вызове функции ей системой автоматически выделяется один **стековый кадр**, содержащий:

+ *аргументы функции*;
+ *локальные переменные*;
+ *возвращаемое значение*;
+ копии значений *регистров процессора*, которые должны быть восстановлены при возврате из функции.

После завершения функции её стековый кадр автоматически удаляется системой простым сдвигом указателя вершины стека.

В реальности любой процесс содержит 2 стека:

+ **пользовательский стек** - используется алгоритмом прикладной программы;
+ **стек ядра** - хранится в *пространстве памяти ядра* и выделяется каждому процессу для выполнения всех действий *системного вызова*.

#### 5.2.1.1. Нелокальный переход - longjmp()

Совершение *нелокального перехода* представляет собой возврат к выполнению заранее отмеченной инструкции, находящейся за пределами исполняемой в данный момент функции.

---

```C
int setjmp(jmp_buf env);
```

Устанавливает место в коде, к которому впоследствии можно совершить переход из выполняемой на тот момент функции, расположенной на вершине пользовательского стека. Совершение перехода через вызов `longjmp()` для процесса выглядит как повторное возвращение значения из `setjmp()`. Первичную установку цели перехода и его фактическое завершение можно различить по возвращаемому результату `setjump()`: оригинальный вызов завершается со значением `0`, фиктивный - с любым другим значением, указанном в соответствующем аргументе `longjmp()`.

Аргумент `env` является выходным параметром, в котором сохраняется копия состояния процесса на момент вызова. В частности, он содержит указатель вершины стека и значения других регистры процессора. Данная информация будет использована в `longjmp()` для возвращения процесса в требуемое состояние.

---

```C
void longjmp(jmp_buf env, int val);
```

Выполняет нелокальный переходит на инструкцию, отмеченную вызовом `setjmp()`. Результатом данного вызова является сброс состояния процесса до указанного в аргументе `env`. Перезапись указателя вершины стека, в частности, приводит к удалению всех стековых кадров, созданных позднее содержащего в себе цель перехода. Аргумент `val` определяет произвольное ненулевое значение, которое будет возвращено при повторном фиктивном завершении вызова `setjmp()`.

---

Обязательным требованием является возвращение выполнения из `longjmp()` в реально существующий на стеке фрейм - цель перехода должна содержаться в некоторой *внешней* по отношению к инициировавшей переход функции, не завершившей свое выполнение.

Вызов `setjmp()` может присутствовать только в следующих контекстах:

+ цельное управляющее выражение инструкции выбора или итерации (`if`, `switch`, `while` и т.д.);
+ операнд унарного отрицания `!`, являющегося цельным управляющим выражением инструкции выбора или итерации;
+ операнд операции сравнения (`==`, `<` и т.д.) при условии, что второй операнд является целочисленной константой, а сама операция является цельным управляющим выражением инструкции выбора или итерации;
+ отдельный вызов функции, не являющийся частью какого-либо выражения.

Выполнение нелокального перехода может испортить реальные значения локальных переменных функции, содержащей цель перехода, вследствие возникновения конфликта с произведенной компилятором оптимизацией (в частности, изменение порядка следования инструкций). По этой причине такие локальные переменные в программах на языке С должны помечаться ключевым словом `volatile`, явно запрещающим их оптимизацию.

#### 5.2.1.2. Расширение стекового кадра - alloca()

```C
void *alloca(size_t size);
```

Выделяет на стеке объем памяти `size`, тем самым расширяя стековый кадр текущей выполняющейся функции с вершины пользовательского стека. Выделенную таким образом память не надо явным образом освобождать (в отличие от `malloc()`), т.к. это происходит автоматически при сворачии стека при завершении функции. В случае *переполнения стека* последствия данного вызова непредсказуемы!

### 5.2.2. Сегмент кучи

Помимо создания автоматических переменных на стеке процессу доступно динамическое выделение памяти в **сегменте кучи**. Данная память существовует независимо от порядка выполнения функций на стеке и требует явной очистки во избежание *утечек памяти*.

#### 5.2.2.1. Системный вызов brk()

Вершина кучи называется **крайней точкой программы (program break)**. Выделение и освобождение памяти в куче сводится к передвижению её вершины, результатом которого является изменение доступного процессу диапазона адресов. В процессе работы программы вершине кучи запрещено оказываться ниже своего первоначального значения, определенного границей сегмента неинициализированнных данных - это привет к ошибке сегментации `SEGFAULT`.

---

```C
int brk(void *end_data_segment);
```

Устанавливает вершину кучи на заданный в аргументе `end_data_segment` адрес с округлением до границы страницы памяти.

---

```C
void *sbrk(intptr_t increment);
```

Изменяет значение адреса вершины кучи, добавляя или отнимая от него заданное аргументом `increment` смещение (определяется знаком указанного приращения).

#### 5.2.2.2. Интерфейс malloc()/free()

Для использования в прикладных программах предназначен библиотечный интерфейс `malloc()/free()`, в частности решающий проблему повторного использования расположенных в глубине куче диапазонов адресов, освобождения которых не может быть произведено обыкновенным сдвигом вершины кучи. Данный интерфейс поддерживает внутри доступного куче пространства *логический двунаправленный список блоков памяти*. Блок состоит из тела (доступный пользовательской программе объем памяти), а также дополнительных полей размера и указателей на соседей. Блок может быть занятым (содержит данные, помещенные в него программой) либо свободным.

![таблица страниц процесса](images/img-7.png)

Выделение памяти осуществляется функцией `malloc()`, которая в первую очередь сканирует список свободных блоков:

+ может быть найден свободный блок в точности требуемого размера;
+ если все существующие блоки имеют избыточный размер, то один из них дробится с созданием нового блока требуемого разера;
+ если все существующие блоки имеют недостаточный размер (либо список вообще пуст), то происходит вызов `sbrk()`, который расширяет кучу на некоторый избыточный объем памяти, и в нем создается новый блок требуемого размера.

При создании блока в самом его начале размещается поле с размером, а пользовательской программе возвращается адрес расположенного далее первого байта тела запрошенного объема.

Освобождение памяти осуществляется функцией `free()`, которая добавляет указанный блок в список свободных, анализируя поле его размера и создавая в его теле указатели на соседние элементы списка. Если освобождаемый блок является граничным, то данная функция может удалить его из списка и выполнить вызов `sbrk()`, который сожмет кучу и вернет системе занимаемое свободными блоками место.

Интерфейс `malloc()/free()` требует аккуратного использования:

+ коду пользовательской программы запрещено обращаться к байтам вне выделенных ей блоков, поскольку их изменение может повредить служебные поля блоков;
+ запрещено высвобождение блока через `free()` *более одного раза*, поскольку в этом случае повреждается структура списка блоков;
+ запрещен вызов функции `free()`, аргумент которой не является адресом первого байта тела освобождаемого блока.

Данный интерфейс включает следующие функции.

---

```C
void *malloc(size_t size);
```

Выделяет в куче блок *неинициализированной* памяти заданного размера и возвращает указатель на первый байт его тела.

---

```C
void free(void *ptr);
```

Высвобождает блок памяти, на первый байт тела которого указывает аргумент `ptr`.

---

```C
void *calloc(size_t numitems, size_t size);
```

Выделяет блок памяти под массив длины `numitems`, содержащий элементы размера `size`. Выделяемая память инициализируется *нулевыми байтами*.

---

```C
void *realloc(void *ptr, size_t size);
```

Устанавливает новый размер `size` ранее выделенного блока памяти, определенного указателем `ptr`. Если происходит расширение блока, то он может быть целиком перемещен на новый адрес, либо новая память будет добавлена в конец существующего тела - значения новых байтов в любом случае *НЕ инициализируются*.

---

```C
void *memalign(
    size_t boundary, 
    size_t size);

int posix_memalign(
    void **memptr, 
    size_t alignment, 
    size_t size);
```

Выделяют *выровненный неинициализированный* блок памяти заданного размера, начинающийся с адреса, *кратного* степени двойки.

---
Различные параметры работы интерфейса `malloc()/free()` могут быть просмотрены и изменены служебными функциями `mallopt()` и `mallinfo()`.

### 5.2.3. Аргументы командной строки и переменные окружения

*Аргументы командной строки* наряду с *переменными среды (окружения)* представляют собой средство передачи информации от родительского процесса его дочернему. И те, и другие размещаются в одной области над пользовательским стеком процесса. Максимально допустимый размер данной области определяется ограничением ресурса процесса `RLIMIT_STACK`.

**Аргументы командной строки** представляют из себя массив символьных строк параметров, переданных процессу при запуске его программы в *оболочке*. *Имя программы*, используемое для запуска программы (можно создать ссылки под различным названием на единственный файл программы), всегда является самым первым аргументом. В коде программы на языке С *аргументы командной строки* доступны через аргументы `argc` и `argv` функции `main()`. Также в Linux они могут быть прочитаны из предоставленного каждому процессу файла `/proc/PID/cmdline`.

![аргументы командной строки](images/img-5.png)

Список **переменных среды** - связанный с каждым процессом массив, содержащий строки параметров вида `имя=значение`. В момент создания процесс наследует КОПИЮ *окружения* от своей *оболочки*. Оболочка также предоставляет ряд команд для работы с окружением:

+ `$ export NAME=value` - *навсегда* добавить указанную переменную окружения к среде используемой оболочки; добавленное значение будет в составе среды наследоваться всеми процессами, запускаемыми из данной оболочки впоследствии;
+ `$ NAME=value program` - добавить указанную переменную окружения только к среде процесса, выполняющего заданную программу;
+ `$ unset` - удалить переменную окружения из среды оболочки;
+ `$ printenv` - вывести список переменных окружения в среде оболочки;
+ `$ env` - позволяет запускать процессы, манипулируя их окружением; поддерживает богатый функционал.

В коде программы на языке С *переменные окружения* доступны через глобальную переменную `environ`. Также в Linux они могут быть прочитаны из предоставленного каждому процессу файла `/proc/PID/environ`.

![переменные окружения](images/img-6.png)

Существует удобный библиотечный интерфейс по работе с переменными окружения в коде программы.

---

```C
char *getenv(const char *name);
```

Возвращает значение переменной окружения по её имени. Полученную строку НЕЛЬЗЯ изменять и желательно скопировать в отдельный буфер.

---

```C
int putenv(char *str);
```

Добавляет к среде новую переменную окружения или изменяет значение существующей переменной. Строка с переменной не переносится в сегмент памяти, содержащий окружение - среда просто начинает указывать на переданную строку. По этой причине строка `str` не должна изменяться или завершать свой период жизни.

---

```C
int setenv(
    const char *name, 
    const char *value, 
    int overwrite);
```

Создает в сегменте памяти среды новую переменную окружения с заданным именем и значением. Если аргумент `overwrite` ненулевой, то переменная перезаписывается, если уже существует.

---

```C
int unsetenv(const char *name);
```

Удаляет из среды переменную окружения с заданным именем, очищая занимаемое ей место.

---

```C
int clearenv(void)
```

Обнуляет окружение, присваивая указателю `environ` значение `NULL`.

Поскольку физически не очищает место, занимаемое переменными, то приводит к *утечкам памяти* - альтернативой является явный вызов `unsetenv()` для каждой существующей переменной.

# 6. Время

При выполнении процесса может представлять интерес замер двух различных типов времени:

+ **календарное время** - длительность реального временного промежутка, отсчитываемого от некоторого фиксированного момента в прошлом. Зачастую точкой отсчета является **Epoch (00:00, 1 января 1970 по UTC)** либо момент старта процесса;
+ **время процесса** - продолжительность использования процессом центрального процессора с момента своего создания.

Реальная точность различных связанных со временем системных вызовов ограничена частотой *программных системных часов*, которые измеряют отрезки времени в единицах, называемых *мгновениями (jiffies)*. *Частота программных* часов ядра определяется его настройкой *Processor type and features:Timer frequency*.

## 6.1. Календарное время

Ядро предоставляет обширный набор функций по определению и изменению (требуется привилегия процесса `CAP_SYS_TIME`) установленного в системе календарного времени в различных форматах.

![функции преобразования времени](/images/img-8.png)

### 6.1.1. Формат timeval

Данный формат представляет собой структуру данных типа `timeval`:

```C
struct timeval
{
    time_t tv_sec;
    suseconds_t tv_usec;
};
```

+ `tv_sec` - количество секунд, прошедших с *Epoch* (формат *unix time*);
+ `tv_usec` - дополнительное количество микросекунд.

---

```C
int gettimeofday(
    struct timeval *tv, 
    struct timezone *tz);
```

Возвращает в аргументе типа `timeval` календарное время системы.

Аргумент типа `timezone` является историческим рудиментом и должен принимать значение `NULL`.

---

```C
int settimeofday(
    const struct timeval *tv, 
    const struct timezone *tz);
```

Устанавливает календарное время системы на основе переданного в аргументе типа `timeval` значения.

Аргумент типа `timezone` является историческим рудиментом и должен принимать значение `NULL`.

---

```C
int adjtime(
    struct timeval *delta, 
    struct timeval *olddelta);
```

Подстраивает календарное время системы, **постепенно** добавляя к системным часам переданное в аргументе `delta` смещение. Если предыдущий процесс подстройки не был завершен, то в аргументе `olddelta` возвращается количество оставшегося недобавленного времени. Если какой-либо из аргументов не требуется, то ему можно присвоить значение `NULL`.

### 6.1.2. Формат unix time

Формат *unix time* представляет собой количество секунд, прошедших с *Epoch*.

---

```C
time_t time(time_t *timep);
```

Возвращает календарное время системы в формате *unix time*.

---

```C
int stime(const time_t *timeptr);
```

Устанавливает календарное время системы на основе переданного в формате *unix time* значения.

---

```C
char *ctime(const time_t *timep);
```

Преобразует календарное время из формата *unix time* в строковое представление вида `Wed Jun 8 14:22:34 2011`.

Возвращенная строка является *статически* выделенной, поэтому данная функция **нереентерабельна**! Реентерабельный аналог: `ctime_r()`.

### 6.1.3. Формат broken-down time

Формат *broken-down time* представляет собой структуру данных типа `tm`:

```C
struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};
```

+ `tm_sec` - секунды (0–60);
+ `tm_min` - минуты (0–59);
+ `tm_hour` - часы (0–23);
+ `tm_mday` - день месяца (1–31);
+ `tm_mon` - месяц (0–11);
+ `tm_year` - год с 1900;
+ `tm_wday` - день недели (воскресенье = 0);
+ `tm_yday` - день в году (0–365; 1 января = 0);
+ `tm_isdst` - флаг летнего времени:
  + `> 0` - летнее время действует;
  + `= 0` - летнее время НЕ действует;
  + `< 0` - информация о летнем времени недоступна.

---

```C
struct tm *gmtime(const time_t *timep);
struct tm *localtime(const time_t *timep);
```

Преобразуют календарное время из формата *unix time* в формат *broken-down time*. Функция `gmtime()` возвращает время в *UTC*, а `localtime()` учитывает *часовой пояс и летнее время*.

Возвращенная структура является *статически* выделенной, поэтому данные функции **нереентерабельны**! Реентерабельный аналоги: `gmtime_r()` и `localtime_r()`.

---

```C
time_t mktime(struct tm *timeptr);
```

Преобразует календарное время из формата *broken-down time* в формат *unix time*. В процессе работы данной функции значения полей аргумента типа `tm` могут быть преобразованы для приведения к указанным в их описании диапазонам - это позволяет передавать в данную функцию аргумент, над которым были выполнены операции временной арифметики.

---

```C
char *asctime(const struct tm *timeptr);
```

Преобразуют календарное время из формата *broken-down time* в строковое представление вида `Wed Jun 8 14:22:34 2011`.

Возвращенная строка является *статически* выделенной, поэтому данная функция **нереентерабельна**! Реентерабельный аналог: `asctime_r()`.

---

```C
size_t strftime(
    char *outstr, 
    size_t maxsize, 
    const char *format,
    const struct tm *timeptr);
```

Преобразует календарное время из формата *broken-down time* в произвольное строковое представление `outstr`, указанного формата `format`. Аргумент `format` содержит заданные последовательности символов вида `%X` (*спецификаторы*), на место которых происходит подстановка значений структуры `timeptr`.

---

```C
char *strptime(
    const char *str, 
    const char *format, 
    struct tm *timeptr);
```

Преобразует календарное время из произвольного строкового представления `str` формата `format` в формат *broken-down time*. Аргумент `format` содержит заданные последовательности символов вида `%X` (*спецификаторы*) и определяет способ заполнения полей структуры типа `tm` на основе содержимого переданной строки. Желательно указывать в `str` строку, содержащую информацию о значениях *всех* полей структуры типа `tm`.

### 6.1.4. Часовые пояса

Программы, которым для работы требуется учитывать **часовой пояс** системы и **режим летнего времени**, могут получить данную информацию из файлов каталога `/usr/share/zoneinfo`. Он содержит по одному файлу с соответствующим именем на каждый часовой пояс: EST, CET, UTC, Iran и т.д. Формат файлов часовых поясов описывается в руководстве `tzfile(5)`, а для их создания используется утилита `zic`. **Местное время** системы определяется файлом `/etc/localtime`, являющимся ссылкой на один из файлов часовых поясов.

Чтобы указать часовой пояс системы при выполнении программы, следует в первую очередь присвоить **переменной окружения `TZ`** строку одного из следующих видов:

+ `:tzfile`

    Содержит относительное путевое имя файла часового пояса `tzfile` в каталоге `zoneinfo`. Пример:

    `$ TZ=":Europe/Berlin"`
  
+ `std offset [ dst [ offset ][ , start-date [ /time ] , end-date [ /time ]]]`

    Содержит следующий набор полей:

  + `std` и `offset` - стандартный часовой пояс и его смещение от UTC;
  + `dst` и `offset` - часовой пояс с учетом режима летнего времени и его смещение от UTC;
  + `start-date` и `end-date` - даты перехода со стандартного на летнее время.

    Пример:

    `$ TZ="CET-1:00:00CEST-2:00:00,M3.5.0,M10.5.0"`

Затем программа осуществляет вызов функции `tzset()`, считывающей информацию из переменной окружения `TZ`.

---

```C
void tzset(void);
```

Проверяет значение переменной среды `TZ` и на её основе инициализирует значения следующих глобальных переменных:

+ `tzname` - названия стандартного и летнего часовых поясов;
+ `daylight` - ненулевое значение, если активен режим летнего времени;
+ `timezone` - смещение в секундах местного времени от UTC.

Если переменная среда `TZ` не была установлена, то данная функция заполняет её значение на основе файла `localtime`. Если переменная среды пустая или недействительная, то будет использован пояс UTC.

## 6.2. Время процесса

Время использования процессом центрального процессора подразделяется на две категории:

+ **время в пользовательском режиме** - потраченное на выполнения иструкций прикладного алгоритмы программы;
+ **время в режиме ядра** - потраченное на выполнение системных вызовов, инициированных процессом.

Команда оболочки `time` позволяет вывести в терминале значения обеих категорий времени процесса.

---

```C
clock_t times(struct tms *buf);

struct tms 
{
    clock_t tms_utime;
    clock_t tms_stime;
    clock_t tms_cutime;
    clock_t tms_cstime;
};


```

Возвращает в аргументе длительности времени процесса, выраженные в количестве *тиков часов*, произошедших с **некоторого момента в прошлом**.

Структура типа `tms` содержит следующие поля:

+ `tms_utime` - время ЦП в пользовательском режиме;
+ `tms_stime` - время ЦП в режиме ядра;
+ `tms_cutime` - время ЦП в пользовательском режиме, потраченное на ожидание завершения всех дочерних процессов;
+ `tms_cstime` - время ЦП в режиме ядра, потраченное на ожидание завершения всех дочерних процессов.

Длительность одного тика в секундах определяется значением `sysconf(_SC_CLK_TCK)`. Значение количества тиков типа `clock_t` не застраховано от переполнения - в этом случае отсчет начнется с 0!

---

```C
clock_t clock(void);
```

Возвращает общее время процесса в режимах пользователя и ядра, выраженное в `CLOCKS_PER_SEC` (равняется $10^6$).

# 7. Локализация

**Локаль** - совокупность параметров системы, определяемых языковыми и культурными нормами. Информация о всех имеющихся в системе локалях размещается в каталоге `/usr/share/locale` (либо `/usr/lib/locale`). Он содержит набор каталогов, каждый из которых описывает локаль определенной географической территории. Каталоги локалей имеют название следующего вида:

`language[_territory[.codeset]][@modifier]`

+ `language` - ISO-код языка;
+ `territory` - ISO-код территории (страны);
+ `codeset` - используемая кодировка символов;
+ `modifier` - уникальный признак, позволяющий отличать каталоги с совпадающими названиями.

Пример названия каталога локали: `de_DE.utf-8@euro`. Стандартная локаль UNIX-систем, определяющая их исторически сложившееся поведения, имеет название `POSIX` (либо синонимичное `C`). Полный список альтернативных имен локалей находится в файле `/usr/share/locale/locale.alias`.

Команда оболочки `locale` позволяет вывести различную информацию о локалях системы.

Cгруппированный по своему назначению набор требующих локализации параметров системы образует *категорию локали*:

+ `LC_CTYPE` - классификация символов (существующие буквы и цифры), правила преобразования верхнего и нижнего регистров;
+ `LC_COLLATE` - правила сортировки символов;
+ `LC_MONETARY` - правила форматирования денежных величин;
+ `LC_NUMERIC` - правила форматирования чисел;
+ `LC_TIME` - правила форматирования даты;
+ `LC_MESSAGES` - форматы сообщений, выводимых программой (например, утвердительные и отрицательные выражения).
+ `LC_ALL` - категория, объединяющая в себе все возможные категории локали.

---

```C
char *setlocale(int category, const char *locale);
```

Устанавливает для процесса в качестве используемой категорию `category` локали `locale`.

Если аргумент `locale` является пустой строкой, то в качестве используемых будут установлены те категории, которые были переданы в процесс в соответствующих переменных окружения. Например: `$ LC_TIME=it_IT LC_NUMERIC=de_DE program`.

Если аргумент `locale` имеет значение `NULL`, то функция только возвращает текущее используемое значение указанной категории.





