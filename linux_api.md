# 1. Введение

Под термином **операционная система** скрывается 2 определения:

+ *в широком смысле* - весь пакет программ, включающий как функционал по управлению ресурсами компьютера, так и сопроводительные стандартные средства: интерпретатор командной строки, графический интерфейс, утилиты и редакторы;
+ *в узком смысле* - только набор основных модулей, управляющих ресурсами компьютера (оперативная память, хранилища, сеть, процессорное время) и занимающихся их распределением.

Для второго определения также используется термин **ядро (kernel)** операционной системы. У работающей операционной системы имеется всего *одно ядро*. *Ядро* выполняет следующие функции:

+ **управление процессами** - ядро выполняет загрузку программ с диска в оперативную память, запуск их выполнения на процессоре, а также финальное освобождение занимаемых ими ресурсов. Запущенный экземпляр программы называют **процессом**. Помимо *создания и завершения процессов* ядро осуществляет их *диспетчеризацию* - контроль доступа к ограниченному объему общих резделяемых ресурсов компьютера и ОС. Linux является *многозадачной ОС с вытеснением* - одновременно могут выполняться несколько процессов, а их менеджментом занимается *диспетчер процессов ядра*;
+ **управление памятью** - Linux применяет технологию управления **виртуальной памятью**, которая позволяет изолировать процессы и закрыть им доступ к чужим данным, а также повысить эффективность использования имеющегося объема *физической памяти* посредством необходимости хранить в текущий момент времени только реально требуемую для выполнения часть данных процесса - в результате в память одновременно может быть загружено большее число программ;
+ **управление устройствами** - ядро предоставляет процессам программные интерфейсы доступа ко всем подключенным периферийным устройствам: устройствам ввода и вывода, накопителям, всевозможным картам расширения, последовательному порту. Также ядро предоставляет унифицированный интерфейс **виртуальной файловой системы**, обеспечивающий единообразный способ обращения к данным на накопителях различной архитектуры;
+ **управление сетью** - ядро включает в себя реализацию стека протоколов TCP/IP и обеспечивает выход в сеть через *интерфейс сокетов*;
+ **управление пользователями** - ядро предоставляет каждому зарегистрированному пользователю собственное независимое рабочее пространство, а также контролирует соблюдение им *прав доступа* к ресурсам ОС и информации других пользователей.
+ **предоставление API ядра** - все описанные выше, а также другие интерфейсы, предоставляемые ядром, объединены в общий программный интерфейс **системных вызовов** - своеобразных точек входа в ядро, через которые процесс может запросить у операционной системы выполнение требуемых ему задач.

**Оболочка (shell)** - программа, осуществляющая чтение *пользовательских команд* и использующая функционал ядра для их выполнения. Оболочка НЕ является частью ядра и разрабатывается отдельно - существует множество различных интерпретаторов команд: *sh, csh, ksh, bash, zsh*. *Оболочкой входа в систему* называют процесс, создаваемый для запуска программы оболочки при первом входе пользователя в систему.

**Системный вызов** - программная точка входа в ядро, позволяющая процессу запрашивать у операционной системы выполнения желаемых действий. Совокупность системных вызовов, реализованных на языке C, образуют *API операционной системы*. При выполнении системный вызов переводит процессор из **пользовательского режима** в **режим ядра**, который открывает ему доступ к *пространству памяти ядра*, содержащему служебные структуры данных операционной системы, а также позволяет вызывать защищенные инструкции (обращение к устройствам, управление памятью, ввод-вывод на устройствах). Каждый системный вызов идентифицируется по *уникальному номеру* и имеет строго определенный набор аргументов.

Выполнение *системного вызова* происходит следующим образом:

1. Прикладная программа инициирует системный вызов, вызвав *функцию-оболочку* из *стандартной библиотеки C*;
2. Функция-оболочка валидирует переданные ей *аргументы системного вызова*, а затем копирует их со своего *стека* в набор регистров процессора, где ожидает их появления ядро;
3. Функция-оболочка помещает *номер системного вызова* в регистр `eax`;
4. Функция-оболочка выполняет *машинную инструкцию системного прерывания* `int 0x80`, переключающую процессор в *режим ядра* и заставляющую его начать выполнять соответствующий *обработчик прерывания*. Современные архитектуры процессоров предоставляют специальную инструкцию `sysenter`, реализующую данный функционал более эффективным способом;
5. Ядро выполняет *обработчик прерывания* `system_call()`, который:
   1. сохраняет текущие значения регистров процессора в *стеке ядра*;
   2. вызывает *функцию обслуживания* переданного *номера системного вызова* `sys_ИМЯ_ВЫЗОВА()`, которая решает требуемую задачу, а затем возвращает *код возврата*;
   3. восстанавливает со *стека ядра* значения регистров процессора и помещает *возвращаемое значение* в *стек прикладной программы*;
   4. передаёт управление функции-оболочке, переводя процессор обратно в *пользовательский режим*;
6. Если возвращенное *обработчиком прерывания* значение свидетельствует об ошибке, то оно помещается в глобальную переменную `errno`;
7. Функция-оболочка завершается, возвращая прикладной программе значение, которое указывает на успех (*неотрицательное число*) или неудачу (*отрицательное число*) системного вызова.

Помимо непосредственных функций-оболочек *стандартная библиотека С* может предоставлять *библиотечные функции*, зачастую скрывающие системный вызов за более удобным интерфейсом или вообще его не использующие, если это позволяется их решаемой задачей. Очевидно, что совершение системного вызова сопровождается существенными издержками, превышающими затраты на обычный вызов функции в пользовательском пространстве.

Текущую версию *стандартной библиотеки С* можно узнать, выполнив файл библиотеки в командной строке или в программе вызвав функцию `gnu_get_libc_version()`.

# 2. Файловый ввод-вывод

**Файл** - это поток байтов. Все системные вызовы ввода-вывода в отношении открытых файлов любого типа совершаются с использованием их уникальных числовых идентификаторов (неотрицательное целое число) - **дескрипторов файлов**. Каждый *процесс* имеет *собственный набор файловых дескрипторов*. Также каждый процесс (если он не является *демоном*) наследует от своей *оболочки* копии 3 стандартных дескрипторов: *ввод, вывод и ошибка*.

| Дескриптор файла | Назначение         | Имя в POSIX   | Поток stdio |
| :--------------- | :----------------- | :------------ | :---------- |
| 0                | Стандартный ввод   | STDIN_FILENO  | stdin       |
| 1                | Стандартный вывод  | STDOUT_FILENO | stdout      |
| 2                | Стандартная ошибка | STDERR_FILENO | stderr      |

Информация о дескрипторах открытых файлов любого процесса системы может быть получена из файлов в каталоге `/proc/PID/fdinfo` *виртуальной файловой системы* **proc**. Для каждого дескриптора каталог содержит файл с его номером в имени.

## 2.1. Универсальный интерфейс ввода-вывода

Linux предоставляет **универсальную модель ввода-вывода** - для выполнения чтения/записи во *все типы файлов*, включая устройства, терминалы и IPC, применяется интерфейс системных вызовов `open/read/write/close`. Данный механизм обеспечивается тем, что каждая файловая система или драйвер устройства самостоятельно реализуют требуемый от них набор операций ввода/вывода, а детали их обработки ядро скрывает внутри себя - в результате при написании прикладных программ можно игнорировать специфику устройства.

### 2.1.1. Открытие файла: open()

```C
int open(
    const char *pathname, 
    int flags, ... 
    /* mode_t mode */);
```

Открывает файл, идентифицированный путевым именем в **аргументе `pathname`**, и возвращает его *файловый дескриптор*. Гарантируется, что созданный файловый дескриптор будет иметь наименьший неиспользуемый номер. Если имя файла содержит *символьную ссылку*, то она разыменовывается.

Если файл не существует, то он может быть автоматически создан при открытии (это определяется битовой маской флагов). В этом случае **аргумент `mode`** применяется для установки *прав доступа* к файлу со стороны *владельца*, *группа* и *других пользователей* (возможные значения описываются позднее) - в противном случае он может быть опущен. Фактически установленный набор прав определяется комбинацией значений *аргумента mode*, ***маски процесса umask*** и ***списка контроля доступа (ACL)** по умолчанию  родительского каталога*.

**Аргумент `flags`** содержит битовую маску режима доступа к файлу, включающую следующие группы флагов:

+ *Флаги режима доступа к файлу* - впоследствии могут быть извлечены:
  + `O_RDONLY` - открытие только для чтения;
  + `O_WRONLY` - открытие только для записи;
  + `O_RDWR` - открытие для чтения и записи;
+ *Флаги создания файла* - управляют поведением вызова; НЕ могут быть извлечены или изменены;
  + `O_CLOEXEC` - установка флага закрытия при выполнении (close-on-exec);
  + `O_CREAT` - создание файла, если он еще не существует;
  + `O_DIRECTORY` - имя файла должно указывать на *каталог*;
  + `O_EXCL` - совместно с `O_CREAT`; требует эксклюзивного создания файла - если он уже существует, то вернуть ошибку;
  + `O_LARGEFILE` - используется в 32-разрядных системах для открытия больших файлов;
  + `O_NOCTTY` - указанному путевому имени запрещено становиться **управляющим терминалом** данного процесса;
  + `O_NOFOLLOW` - не разыменовывать символьные ссылки;
  + `O_TRUNC` - усечение существующего файла до нулевой длины;
+ *Флаги состояния файла* - впоследствии могут извлечены и изменены:
  + `O_APPEND`
