# 1. Введение

Под термином **операционная система** скрывается 2 определения:

+ *в широком смысле* - весь пакет программ, включающий как функционал по управлению ресурсами компьютера, так и сопроводительные стандартные средства: интерпретатор командной строки, графический интерфейс, утилиты и редакторы;
+ *в узком смысле* - только набор основных модулей, управляющих ресурсами компьютера (оперативная память, хранилища, сеть, процессорное время) и занимающихся их распределением.

Для второго определения также используется термин **ядро (kernel)** операционной системы. У работающей операционной системы имеется всего *одно ядро*. *Ядро* выполняет следующие функции:

+ **управление процессами** - ядро выполняет загрузку программ с диска в оперативную память, запуск их выполнения на процессоре, а также финальное освобождение занимаемых ими ресурсов. Запущенный экземпляр программы называют **процессом**. Помимо *создания и завершения процессов* ядро осуществляет их *диспетчеризацию* - контроль доступа к ограниченному объему общих резделяемых ресурсов компьютера и ОС. Linux является *многозадачной ОС с вытеснением* - одновременно могут выполняться несколько процессов, а их менеджментом занимается *диспетчер процессов ядра*;
+ **управление памятью** - Linux применяет технологию управления **виртуальной памятью**, которая позволяет изолировать процессы и закрыть им доступ к чужим данным, а также повысить эффективность использования имеющегося объема *физической памяти* посредством необходимости хранить в текущий момент времени только реально требуемую для выполнения часть данных процесса - в результате в память одновременно может быть загружено большее число программ;
+ **управление устройствами** - ядро предоставляет процессам программные интерфейсы доступа ко всем подключенным периферийным устройствам: устройствам ввода и вывода, накопителям, всевозможным картам расширения, последовательному порту. Также ядро предоставляет унифицированный интерфейс **виртуальной файловой системы**, обеспечивающий единообразный способ обращения к данным на накопителях различной архитектуры;
+ **управление сетью** - ядро включает в себя реализацию стека протоколов TCP/IP и обеспечивает выход в сеть через *интерфейс сокетов*;
+ **управление пользователями** - ядро предоставляет каждому зарегистрированному пользователю собственное независимое рабочее пространство, а также контролирует соблюдение им *прав доступа* к ресурсам ОС и информации других пользователей.
+ **предоставление API ядра** - все описанные выше, а также другие интерфейсы, предоставляемые ядром, объединены в общий программный интерфейс **системных вызовов** - своеобразных точек входа в ядро, через которые процесс может запросить у операционной системы выполнение требуемых ему задач.

**Оболочка (shell)** - программа, осуществляющая чтение *пользовательских команд* и использующая функционал ядра для их выполнения. Оболочка НЕ является частью ядра и разрабатывается отдельно - существует множество различных интерпретаторов команд: *sh, csh, ksh, bash, zsh*. *Оболочкой входа в систему* называют процесс, создаваемый для запуска программы оболочки при первом входе пользователя в систему.

**Системный вызов** - программная точка входа в ядро, позволяющая процессу запрашивать у операционной системы выполнения желаемых действий. Совокупность системных вызовов, реализованных на языке C, образуют *API операционной системы*. При выполнении системный вызов переводит процессор из **пользовательского режима** в **режим ядра**, который открывает ему доступ к *пространству памяти ядра*, содержащему служебные структуры данных операционной системы, а также позволяет вызывать защищенные инструкции (обращение к устройствам, управление памятью, ввод-вывод на устройствах). Каждый системный вызов идентифицируется по *уникальному номеру* и имеет строго определенный набор аргументов.

Выполнение *системного вызова* происходит следующим образом:

1. Прикладная программа инициирует системный вызов, вызвав *функцию-оболочку* из *стандартной библиотеки C*;
2. Функция-оболочка валидирует переданные ей *аргументы системного вызова*, а затем копирует их со своего *стека* в набор регистров процессора, где ожидает их появления ядро;
3. Функция-оболочка помещает *номер системного вызова* в регистр `eax`;
4. Функция-оболочка выполняет *машинную инструкцию системного прерывания* `int 0x80`, переключающую процессор в *режим ядра* и заставляющую его начать выполнять соответствующий *обработчик прерывания*. Современные архитектуры процессоров предоставляют специальную инструкцию `sysenter`, реализующую данный функционал более эффективным способом;
5. Ядро выполняет *обработчик прерывания* `system_call()`, который:
   1. сохраняет текущие значения регистров процессора в *стеке ядра*;
   2. вызывает *функцию обслуживания* переданного *номера системного вызова* `sys_ИМЯ_ВЫЗОВА()`, которая решает требуемую задачу, а затем возвращает *код возврата*;
   3. восстанавливает со *стека ядра* значения регистров процессора и помещает *возвращаемое значение* в *стек прикладной программы*;
   4. передаёт управление функции-оболочке, переводя процессор обратно в *пользовательский режим*;
6. Если возвращенное *обработчиком прерывания* значение свидетельствует об ошибке, то оно помещается в глобальную переменную `errno`;
7. Функция-оболочка завершается, возвращая прикладной программе значение, которое указывает на успех (*неотрицательное число*) или неудачу (*отрицательное число*) системного вызова.

Выполнение любого системного вызова происходит **атомарно**! Ядро гарантирует, что совершаемая им последовательность действий будет представлять собой единую неделимую операцию, которая не может быть прервана другим процессом или *потоком* - системный вызов либо успешно завершается, либо возвращает ошибку.

Помимо непосредственных функций-оболочек *стандартная библиотека С* может предоставлять *библиотечные функции*, зачастую скрывающие системный вызов за более удобным интерфейсом или вообще его не использующие, если это позволяется их решаемой задачей. Очевидно, что совершение системного вызова сопровождается существенными издержками, превышающими затраты на обычный вызов функции в пользовательском пространстве.

Текущую версию *стандартной библиотеки С* можно узнать, выполнив файл библиотеки в командной строке или в программе вызвав функцию `gnu_get_libc_version()`.

# 2. Файловый ввод-вывод

**Файл** - это поток байтов, представляющих собой данные. В операционной системе с файлом ассоциированы 3 сущности:

1. **таблица индексных дескрипторов** файловой системы;
2. общесистемная **таблица открытых файлов**;
3. **таблица файловых дескрипторов** каждого процесса.

![таблицы файловых дескрипторов](images/img-2.png)

**Дескриптор файла** - это целочисленный идентификатор, присваиваемый файлу при его *открытии* процессом. Чтобы совершить над файлом большинство действий, в первую очередь необходимо получить его дескриптор, а уже затем передать его в качестве аргумента в системный вызов.

Для каждого процесса ядро поддерживает его *собственную* **таблицу дескрипторов файлов**. Её записи содержат:

+ *набор флагов* данного дескриптора, единственным возможным членом которого является флаг *close-on-exec* `FD_CLOEXEC`;
+ ссылку на соответствующую *дескрипцию открытого файла*.

На *общесистемном* уровне ядро поддерживает существующую в единственном экземпляре **таблицу открытых файлов**. Её записи, называемые **дескрипциями открытых файлов**, содержат следующую информацию о файле, над которым было произведено *открытие*:

+ текущее **файловое смещение**, также называемое *файловым указателем*, которое определяет позицию в файле, с которой будет выполняться следующая операция чтения/записи;
+ *флаги состояния* файла;
+ *режим доступа* к файлу;
+ установки механизма *ввода-вывода на основе сигналов*;
+ ссылка на соответствующий *индексный дескриптор* файла;

Само понятие файла как объединения взаимосвязанных данных вводит *файловая система*, которая для обеспечения своих функций (хранение информации) поддерживает реестр, называемый **таблицей индексных дескрипторов**. Её записи содержат:

+ тип файла;
+ *права доступа* к файлу со стороны пользователей ОС;
+ список *блокировок*, удерживаемых на файле;
+ всевозможные свойства файла: размер, метки времени и прочие.

Отдельная *дескрипция файла* создаётся при каждом его *открытии* с помощью системного вызова `open()`. Дескрипция, в свою очередь, порождает связанный с ней единственный *дескриптор файла*. Дополнительные экземпляры *дескрипторов* могут быть получены *дублированием* исходного с помощью набора системных вызовов `dup()`, *наследованием* от родительского процесса или передачей через *сокет домена UNIX*. Очевидно, что все файловые дескрипторы, ссылающиеся на некую единственную дескрипцию, будут иметь доступ к одним и тем же её полям (в особенности к *смещению* и *флагам состояния*), однако каждый из них будет обладать собственным значением флага *close-on-exec*.

Номера всех файловых дескрипторов начинаются с 0 и следуют друг за другом по возрастанию, причем при создании дескриптора любым способом ему гарантированно выдается *наименьший* доступный на текущий момент номер. Любой процесс, не являющийся *демоном*, будет по умолчанию обладать набором 3 *стандартных дескрипторов*, унаследованных им от своей оболочки:

+ `STDIN_FILENO` - стандартный *ввод*, номер `0`;
+ `STDOUT_FILENO` - стандартный *вывод*, номер `1`;
+ `STDERR_FILENO` - cтандартная *ошибка*, номер `2`.

Для каждого открытого файла ядро хранит **файловое смещение (файловый указатель)**, определяющее позицию в байтах, с которой будет выполняться следующая операция ввода-вывода. При открытии файла смещение устанавливается на его начало (если явно не указано иное), а затем последовательно сдвигается каждым успешно завершенным чтением или записью. Также файловый указатель может быть перемещен на требуемую позицию явным образом, причем его новое положение может располагаться за текущим концом файла - если по такой позиции будет выполнена операция записи, то образуется **файловая дыра**. До тех пор пока файловая дыра пуста (в её пределах отсутствуют явно записанные данные), она не занимает места, и файловая система не выделяет для неё дисковые блоки. Однако с программной точки зрения дыра хранит данные, и чтение из неё будет возращать нулевые байты - это означает, что номинальный объём файла, может превышать его реальный физический размер. Механизм файловых дыр позволяет экономить дисковое пространство, занимаемое слабозаполненными (разреженными, sparce) файлами. *Файлы дампа ядра*, содержащие слепок виртуальной памяти процесса на момент его завершения, являются их харакретными представителями.

![файловая дыра](images/img-1.png)

Ядро предоставляет ряд *виртуальных каналогов* с информацией о файловых дескрипторах процессов:

+ `/proc/PID/fdinfo` - для процесса с идентификатором `PID` содержит справочные файлы (смещение, флаги и т.д.) по одному на каждый из его файловых дескрипторов;
+ `/proc/self/fdinfo` - предоставляемая каждому процессу ядром *символьная ссылка* на его собственный каталог `fdinfo`;
+ `/proc/PID/fd` - для процесса с идентификатором `PID` содержит *символьные ссылки* на файлы, открытые им через каждый из своих файловых дескрипторов. В Linux открытие файла из данного каталога приводит к *повторному открытию* (с созданием новой *дескрипции*) исходного файла. Зачастую файлы из данного каталога используются для передачи стандартных ввода/ввывода процесса, не имеющих существующей в файловой системе сущности, в утилиты командной строки, принимающие в качестве аргументов путевые имена файлов;
+ `/proc/self/fd` - предоставляемая каждому процессу ядром *символьная ссылка* на его собственный каталог `fd`;
+ `/dev/fd` - аналог описанной выше *символьной ссылки* на каталог `fd` процесса.

## 2.1. Универсальный интерфейс ввода-вывода

Linux предоставляет **универсальную модель ввода-вывода** - для выполнения чтения/записи во *все типы файлов*, включая устройства, терминалы и IPC, применяется интерфейс системных вызовов `open/read/write/close`. Данный механизм обеспечивается тем, что каждая файловая система или драйвер устройства самостоятельно реализуют требуемый от них набор операций ввода/вывода, а детали их обработки ядро скрывает внутри себя - в результате при написании прикладных программ можно игнорировать специфику устройства.

---

```C
int open(
    const char *pathname, 
    int flags, ... 
    /* mode_t mode */);
```

Открывает файл, идентифицированный путевым именем в аргументе `pathname`, и возвращает его *файловый дескриптор*. Гарантируется, что созданный файловый дескриптор будет иметь наименьший неиспользуемый номер. Если имя файла содержит *символьную ссылку*, то она разыменовывается.

Если файл не существует, то он может быть автоматически создан при открытии (это определяется битовой маской флагов). В этом случае аргумент `mode` применяется для установки *прав доступа* к файлу со стороны *владельца*, *группа* и *других пользователей* (возможные значения описываются позднее) - в противном случае он может быть опущен. Фактически установленный набор прав определяется комбинацией значений *аргумента mode*, ***маски процесса umask*** и ***списка контроля доступа (ACL)** по умолчанию  родительского каталога*.

Аргумент `flags` содержит битовую маску режима доступа к файлу, включающую следующие группы флагов:

+ *Флаги режима доступа к файлу* - впоследствии могут быть извлечены:
  + `O_RDONLY` - открыть файл только для чтения;
  + `O_WRONLY` - открыть файл только для записи;
  + `O_RDWR` - открыть файл для чтения и записи;
+ *Флаги создания файла* - управляют поведением вызова; НЕ могут быть извлечены или изменены;
  + `O_CLOEXEC` - установить флаг файлового дескриптора close-on-exec `FD_CLOEXEC`;
  + `O_CREAT` - создать новый файл, если он не существует; требует обязательного наличия аргумента вызова `mode`;
  + `O_DIRECTORY` - путевое имя `pathname` должно указывать на *каталог*;
  + `O_EXCL` - указывается совместно с `O_CREAT`; создать новый файл либо вернуть ошибку, если он уже существует (*эксклюзивное создание файла*);
  + `O_LARGEFILE` - используется в 32-разрядных системах для открытия больших файлов, по размеру превышающих 2 Гбайта;
  + `O_NOCTTY` - запретить терминалу под путевым именем `pathname` становиться **управляющим терминалом** данного процесса;
  + `O_NOFOLLOW` - не разыменовывать символьные ссылки;
  + `O_TRUNC` - очистить открываемый файл;
+ *Флаги состояния файла* - впоследствии могут извлечены и изменены:
  + `O_APPEND` - перевести *указатель файла (смещение)* в его конец;
  + `O_NONBLOCK` - открыть файл в *неблокируемом режиме*: если операция ввода-вывода над файлом не может *мгновенно* завершиться *полностью*, то она либо целиком отменяется, возвращая синонимичные значения `EAGAIN` или `EWOULDBLOCK` в переменной `errno`, либо выполняется частично, возвращая реально обработанное количество байт;
  + `O_ASYNC` - часть механизма *ввода-вывода на основе сигналов*; отправлять процессу *сигнал*, когда указанный дескриптор становится доступен для выполнения ввода-вывода; может быть установлен только вызовом `fcntl(F_SETFL)`;
  + `O_DIRECT` - выполнять операции ввода-вывода в обход *дисковых буферов ядра*;
  + `O_SYNC` - выполнять операции ввода-вывода в *синхронном режиме*;
  + `O_DSYNC` - выполнять операции синхронного ввода-вывода с *сохранением целостности данных*;
  + `O_NOATIME` - не обновлять время последнего обращения к файлу при его чтении; *действующий UID* процесса должен соответствовать владельцу файла, либо процесс должен быть *привилегированным* (`CAP_FOWNER`).

---

```C
ssize_t read(
    int fd, 
    void *buffer, 
    size_t count);
```

Считывает из указанного фала максимально `count` байт в заранее выделенный буфер `buffer`. В случае успеха возвращает число *реально прочитанных* байт, которое может оказаться меньше указанного максимального. Попытка чтения за текущим концом файла вернёт 0 байт - данные отсутствуют.

---

```C
ssize_t write(
    int fd, 
    const void *buffer, 
    size_t count);
```

Записывает в указанный файл максимально `count` байт, хранящихся в буфере `buffer`. В случае успеха возвращает число *реально записанных* байт, которое может оказаться меньше указанного максимального. Завершение данного вызова не гарантирует перенос данных на устройство, поскольку ядро выполняет буферизацию дискового ввода-вывода.

---

```C
off_t lseek(int fd, off_t offset, int whence);
```

Сдвигает файловый указатель на `offset` байт относительно позиции `whence`. В случае успеха возвращает новое полученное значение файлового смещения.

Аргумент `whence` принимает следующие значения:

+ `SEEK_SET` - отправной точкой служит начало файла (нулевая позиция);
+ `SEEK_CUR` - отправной точкой служит текущее положение файлового указателя;
+ `SEEK_END` - отправной точкой служит позиция, *следующая за последним байтом файла*;

Аргумент `offset` является целым числом со знаком: нулевое значение просто вернет текущее смещение, а отрицательное заставит указатель передвинуться в противоположном направлении, однако *выходить за начало файла ЗАПРЕЩЕНО*.

Зачастую данный вызов применяется к обыкновенным файлам данных на диске - он не может быть вызван над *FIFO*, *сокетом* и *терминалом*. Файловое смещение - это сущность ядра, и его изменение не требует физического доступа к устройству хранения.

---

```C
int close(int fd);
```

Закрывает открытый файловый дескриптор, высвобождая его для повторного использования процессом. Завершение процесса также приводит к автоматическому закрытию всех его файловых дескрипторов.

---

```C
int truncate(const char *pathname, off_t length);

int ftruncate(int fd, off_t length);
```

Устанавливают для файла, заданного через путевое имя `pathname` или дескриптор `fd`, новый размер `length`. Если файл *урезается*, то избыточные данные теряются. Если файл *увеличивается* в размере, то добавляются нулевые байты, либо образуется файловая дыра. При выполнении данного вызова к файлу применяются стандартные проверки режима и прав доступа.

---

```C
int fcntl(int fd, int cmd, ...);
```

Позволяет извлечь либо установить флаги *режима доступа* и *состояния* указанного файлового дескриптора. Аргумента `cmd` определяет выполняемое действие и принимает значения `F_GETFL` или `F_SETFL`. При установке флага(ов) вызов принимает дополнительный содержащий их параметр.

---

```C
int ioctl(int fd, int request, ... /* argp */);
```

Вызов общего назначения, позволяющий выполнять над указанным файлом или устройством операции, выходящие за пределы описанной универсальной модели. Аргумент `request`, обозначающий совершаемую операцию, обычно сопровождается набором её входных параметров `argp` любого требуемого типа.

## 2.2. Дополнительные операции ввода-вывода

```C
ssize_t pread(
    int fd, 
    void *buf, 
    size_t count, 
    off_t offset);

ssize_t pwrite(
    int fd, 
    const void *buf, 
    size_t count, 
    off_t offset);
```

Являются аналогами стандартных вызовов, однако осуществляют ввод-вывод с заданного смещения `offset` от начала файла, а не с текущей позиции файлового указателя. *НЕ изменяют* значение *файлового смещения*, содержащее в общесистемной дескрипции файла. Тип файла, над которым выполняются данные вызовы, должен поддерживать произвольную установку файлового смещения.

---

```C
ssize_t readv(
    int fd, 
    const struct iovec *iov, 
    int iovcnt);

ssize_t writev(
    int fd, 
    const struct iovec *iov, 
    int iovcnt);
```

Осуществляют *фрагментированный ввод-вывод (scatter-gather IO)*: считывают или записывают непрерывную последовательность байтов файла в `iovcnt` буферов в порядке их следования в наборе `iov`. Поскольку данные вызовы совершаются *атомарно*, то *любые* операции ввода-вывода над указанным файлом в других процессах или потоках не могут нарушить непрерывность обрабатываемой последовательности данных.

---

```C
ssize_t preadv(
    int fd, 
    const struct iovec *iov, 
    int iovcnt, 
    off_t offset);

ssize_t pwritev(
    int fd, 
    const struct iovec *iov, 
    int iovcnt, 
    off_t offset);
```

Фрагментированный ввод-вывод по заданному смещению - являются комбинацией описанных выше вызовов.

## 2.3. Дублирование файловых дескрипторов

```C
int dup(int oldfd);
```

Создает дубликат исходного дескриптора `oldfd`, указывающий на ту же дескрипцию файла в общесистемной таблице.

---

```C
int dup2(int oldfd, int newfd);
```

Создает дубликат исходного дескриптора `oldfd`, указывающий на ту же дескрипцию файла в общесистемной таблице, присваивая ему номер дескриптора `newfd`. Если `newfd` уже существует, то сначала он будет **закрыт**, причем закрытие и повторное открытие будут выполнены *атомарно*. Если в аргументы вызова передан один и тот же дескриптор, то никаких действий не совершается.

---

```C
int dup3(int oldfd, int newfd, int flags);
```

Аналог вызова `dup2()`, дополнительно позволяющий с помощью значения `O_CLOEXEC` аргумента `flags` сразу установить в результирующем дескрипторе флаг close-on-exec.

## 2.4. Создание временных файлов

Если программе на время работы требуются временные файлы, которые будут уничтожены по её завершении, то она может воспользоваться набором библиотечных функций.

---

```C
int mkstemp(char *template);
```

Создаёт и открывает для чтения/записи, возвращая его дескриптор, файл, шаблон `template` путевого имени которого обязан заканчиваться символьной последовательностью `XXXXXX` - она будет автоматически заменена ядром на строку, придающую имени уникальность. Открываемый файл получает права чтения/записи для владельца, а также флаг `O_EXCL`, гарантирующий эксклюзивный доступ. Обычно сразу после создания файла его запись в файловой системе уничтожают вызовом `unlink()` - он продолжит быть доступен процессу через свой дескриптор и будет окончательно удален при его закрытии.

---

```C
FILE *tmpfile(void);
```

Создаёт и эксклюзивно (`O_EXCL`) открывает для чтения/записи временный файл с уникальным именем, возвращая его *файловый поток* библиотеки stdio языка C. При закрытии он будет автоматически удалён.
