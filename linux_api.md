# 1. Введение

Под термином **операционная система** скрывается 2 определения:

+ *в широком смысле* - весь пакет программ, включающий как функционал по управлению ресурсами компьютера, так и сопроводительные стандартные средства: интерпретатор командной строки, графический интерфейс, утилиты и редакторы;
+ *в узком смысле* - только набор основных модулей, управляющих ресурсами компьютера (оперативная память, хранилища, сеть, процессорное время) и занимающихся их распределением.

Для второго определения также используется термин **ядро (kernel)** операционной системы. У работающей операционной системы имеется всего *одно ядро*. *Ядро* выполняет следующие функции:

+ **управление процессами** - ядро выполняет загрузку программ с диска в оперативную память, запуск их выполнения на процессоре, а также финальное освобождение занимаемых ими ресурсов. Запущенный экземпляр программы называют **процессом**. Помимо *создания и завершения процессов* ядро осуществляет их *диспетчеризацию* - контроль доступа к ограниченному объему общих резделяемых ресурсов компьютера и ОС. Linux является *многозадачной ОС с вытеснением* - одновременно могут выполняться несколько процессов, а их менеджментом занимается *диспетчер процессов ядра*;
+ **управление памятью** - Linux применяет технологию управления **виртуальной памятью**, которая позволяет изолировать процессы и закрыть им доступ к чужим данным, а также повысить эффективность использования имеющегося объема *физической памяти* посредством необходимости хранить в текущий момент времени только реально требуемую для выполнения часть данных процесса - в результате в память одновременно может быть загружено большее число программ;
+ **управление устройствами** - ядро предоставляет процессам программные интерфейсы доступа ко всем подключенным периферийным устройствам: устройствам ввода и вывода, накопителям, всевозможным картам расширения, последовательному порту. Также ядро предоставляет унифицированный интерфейс **виртуальной файловой системы**, обеспечивающий единообразный способ обращения к данным на накопителях различной архитектуры;
+ **управление сетью** - ядро включает в себя реализацию стека протоколов TCP/IP и обеспечивает выход в сеть через *интерфейс сокетов*;
+ **управление пользователями** - ядро предоставляет каждому зарегистрированному пользователю собственное независимое рабочее пространство, а также контролирует соблюдение им *прав доступа* к ресурсам ОС и информации других пользователей.
+ **предоставление API ядра** - все описанные выше, а также другие интерфейсы, предоставляемые ядром, объединены в общий программный интерфейс **системных вызовов** - своеобразных точек входа в ядро, через которые процесс может запросить у операционной системы выполнение требуемых ему задач.

**Оболочка (shell)** - программа, осуществляющая чтение *пользовательских команд* и использующая функционал ядра для их выполнения. Оболочка НЕ является частью ядра и разрабатывается отдельно - существует множество различных интерпретаторов команд: *sh, csh, ksh, bash, zsh*. *Оболочкой входа в систему* называют процесс, создаваемый для запуска программы оболочки при первом входе пользователя в систему.

**Системный вызов** - программная точка входа в ядро, позволяющая процессу запрашивать у операционной системы выполнения желаемых действий. Совокупность системных вызовов, реализованных на языке C, образуют *API операционной системы*. При выполнении системный вызов переводит процессор из **пользовательского режима** в **режим ядра**, который открывает ему доступ к *пространству памяти ядра*, содержащему служебные структуры данных операционной системы, а также позволяет вызывать защищенные инструкции (обращение к устройствам, управление памятью, ввод-вывод на устройствах). Каждый системный вызов идентифицируется по *уникальному номеру* и имеет строго определенный набор аргументов.

Выполнение *системного вызова* происходит следующим образом:

1. Прикладная программа инициирует системный вызов, вызвав *функцию-оболочку* из *стандартной библиотеки C*;
2. Функция-оболочка валидирует переданные ей *аргументы системного вызова*, а затем копирует их со своего *стека* в набор регистров процессора, где ожидает их появления ядро;
3. Функция-оболочка помещает *номер системного вызова* в регистр `eax`;
4. Функция-оболочка выполняет *машинную инструкцию системного прерывания* `int 0x80`, переключающую процессор в *режим ядра* и заставляющую его начать выполнять соответствующий *обработчик прерывания*. Современные архитектуры процессоров предоставляют специальную инструкцию `sysenter`, реализующую данный функционал более эффективным способом;
5. Ядро выполняет *обработчик прерывания* `system_call()`, который:
   1. сохраняет текущие значения регистров процессора в *стеке ядра*;
   2. вызывает *функцию обслуживания* переданного *номера системного вызова* `sys_ИМЯ_ВЫЗОВА()`, которая решает требуемую задачу, а затем возвращает *код возврата*;
   3. восстанавливает со *стека ядра* значения регистров процессора и помещает *возвращаемое значение* в *стек прикладной программы*;
   4. передаёт управление функции-оболочке, переводя процессор обратно в *пользовательский режим*;
6. Если возвращенное *обработчиком прерывания* значение свидетельствует об ошибке, то оно помещается в глобальную переменную `errno`;
7. Функция-оболочка завершается, возвращая прикладной программе значение, которое указывает на успех (*неотрицательное число*) или неудачу (*отрицательное число*) системного вызова.

Выполнение любого системного вызова происходит **атомарно**! Ядро гарантирует, что совершаемая им последовательность действий будет представлять собой единую неделимую операцию, которая не может быть прервана другим процессом или *потоком* - системный вызов либо успешно завершается, либо возвращает ошибку.

Помимо непосредственных функций-оболочек *стандартная библиотека С* может предоставлять *библиотечные функции*, зачастую скрывающие системный вызов за более удобным интерфейсом или вообще его не использующие, если это позволяется их решаемой задачей. Очевидно, что совершение системного вызова сопровождается существенными издержками, превышающими затраты на обычный вызов функции в пользовательском пространстве.

Текущую версию *стандартной библиотеки С* можно узнать, выполнив файл библиотеки в командной строке или в программе вызвав функцию `gnu_get_libc_version()`.

# 2. Файловый ввод-вывод

**Файл** - это поток байтов, представляющих собой данные. В операционной системе с файлом ассоциированы 3 сущности:

1. **таблица индексных дескрипторов** файловой системы;
2. общесистемная **таблица открытых файлов**;
3. **таблица файловых дескрипторов** каждого процесса.

![таблицы файловых дескрипторов](images/img-2.png)

**Дескриптор файла** - это целочисленный идентификатор, присваиваемый файлу при его *открытии* процессом. Чтобы совершить над файлом большинство действий, в первую очередь необходимо получить его дескриптор, а уже затем передать его в качестве аргумента в системный вызов.

Для каждого процесса ядро поддерживает его *собственную* **таблицу дескрипторов файлов**. Её записи содержат:

+ *набор флагов* данного дескриптора, единственным возможным членом которого является флаг *close-on-exec* `FD_CLOEXEC`;
+ ссылку на соответствующую *дескрипцию открытого файла*.

На *общесистемном* уровне ядро поддерживает существующую в единственном экземпляре **таблицу открытых файлов**. Её записи, называемые **дескрипциями открытых файлов**, содержат следующую информацию о файле, над которым было произведено *открытие*:

+ текущее **файловое смещение**, также называемое *файловым указателем*, которое определяет позицию в файле, с которой будет выполняться следующая операция чтения/записи;
+ *флаги состояния* файла;
+ *режим доступа* к файлу;
+ установки механизма *ввода-вывода на основе сигналов*;
+ ссылка на соответствующий *индексный дескриптор* файла;

Само понятие файла как объединения взаимосвязанных данных вводит *файловая система*, которая для обеспечения своих функций (хранение информации) поддерживает реестр, называемый **таблицей индексных дескрипторов**. Её записи содержат:

+ тип файла;
+ *права доступа* к файлу со стороны пользователей ОС;
+ список *блокировок*, удерживаемых на файле;
+ всевозможные свойства файла: размер, метки времени и прочие.

Отдельная *дескрипция файла* создаётся при каждом его *открытии* с помощью системного вызова `open()`. Дескрипция, в свою очередь, порождает связанный с ней единственный *дескриптор файла*. Дополнительные экземпляры *дескрипторов* могут быть получены *дублированием* исходного с помощью набора системных вызовов `dup()`, *наследованием* от родительского процесса или передачей через *сокет домена UNIX*. Очевидно, что все файловые дескрипторы, ссылающиеся на некую единственную дескрипцию, будут иметь доступ к одним и тем же её полям (в особенности к *смещению* и *флагам состояния*), однако каждый из них будет обладать собственным значением флага *close-on-exec*.

Номера всех файловых дескрипторов начинаются с 0 и следуют друг за другом по возрастанию, причем при создании дескриптора любым способом ему гарантированно выдается *наименьший* доступный на текущий момент номер. Любой процесс, не являющийся *демоном*, будет по умолчанию обладать набором 3 *стандартных дескрипторов*, унаследованных им от своей оболочки:

+ `STDIN_FILENO` - стандартный *ввод*, номер `0`;
+ `STDOUT_FILENO` - стандартный *вывод*, номер `1`;
+ `STDERR_FILENO` - cтандартная *ошибка*, номер `2`.

Для каждого открытого файла ядро хранит **файловое смещение (файловый указатель)**, определяющее позицию в байтах, с которой будет выполняться следующая операция ввода-вывода. При открытии файла смещение устанавливается на его начало (если явно не указано иное), а затем последовательно сдвигается каждым успешно завершенным чтением или записью. Также файловый указатель может быть перемещен на требуемую позицию явным образом, причем его новое положение может располагаться за текущим концом файла - если по такой позиции будет выполнена операция записи, то образуется **файловая дыра**. До тех пор пока файловая дыра пуста (в её пределах отсутствуют явно записанные данные), она не занимает места, и файловая система не выделяет для неё дисковые блоки. Однако с программной точки зрения дыра хранит данные, и чтение из неё будет возращать нулевые байты - это означает, что номинальный объём файла, может превышать его реальный физический размер. Механизм файловых дыр позволяет экономить дисковое пространство, занимаемое слабозаполненными (разреженными, sparce) файлами. *Файлы дампа ядра*, содержащие слепок виртуальной памяти процесса на момент его завершения, являются их харакретными представителями.

![файловая дыра](images/img-1.png)

Ядро предоставляет ряд *виртуальных каналогов* с информацией о файловых дескрипторах процессов:

+ `/proc/PID/fdinfo` - для процесса с идентификатором `PID` содержит справочные файлы (смещение, флаги и т.д.) по одному на каждый из его файловых дескрипторов;
+ `/proc/self/fdinfo` - предоставляемая каждому процессу ядром *символьная ссылка* на его собственный каталог `fdinfo`;
+ `/proc/PID/fd` - для процесса с идентификатором `PID` содержит *символьные ссылки* на файлы, открытые им через каждый из своих файловых дескрипторов. В Linux открытие файла из данного каталога приводит к *повторному открытию* (с созданием новой *дескрипции*) исходного файла. Зачастую файлы из данного каталога используются для передачи стандартных ввода/ввывода процесса, не имеющих существующей в файловой системе сущности, в утилиты командной строки, принимающие в качестве аргументов путевые имена файлов;
+ `/proc/self/fd` - предоставляемая каждому процессу ядром *символьная ссылка* на его собственный каталог `fd`;
+ `/dev/fd` - аналог описанной выше *символьной ссылки* на каталог `fd` процесса.

## 2.1. Универсальный интерфейс ввода-вывода

Linux предоставляет **универсальную модель ввода-вывода** - для выполнения чтения/записи во *все типы файлов*, включая устройства, терминалы и IPC, применяется интерфейс системных вызовов `open/read/write/close`. Данный механизм обеспечивается тем, что каждая файловая система или драйвер устройства самостоятельно реализуют требуемый от них набор операций ввода/вывода, а детали их обработки ядро скрывает внутри себя - в результате при написании прикладных программ можно игнорировать специфику устройства.

---

```C
int open(
    const char *pathname, 
    int flags, ... 
    /* mode_t mode */);
```

Открывает файл, идентифицированный путевым именем в аргументе `pathname`, и возвращает его *файловый дескриптор*. Гарантируется, что созданный файловый дескриптор будет иметь наименьший неиспользуемый номер. Если имя файла содержит *символьную ссылку*, то она разыменовывается.

Если файл не существует, то он может быть автоматически создан при открытии (это определяется битовой маской флагов). В этом случае аргумент `mode` применяется для установки *прав доступа* к файлу со стороны *владельца*, *группа* и *других пользователей* (возможные значения описываются позднее) - в противном случае он может быть опущен. Фактически установленный набор прав определяется комбинацией значений *аргумента mode*, ***маски процесса umask*** и ***списка контроля доступа (ACL)** по умолчанию  родительского каталога*.

Аргумент `flags` содержит битовую маску режима доступа к файлу, включающую следующие группы флагов:

+ *Флаги режима доступа к файлу* - впоследствии могут быть извлечены:
  + `O_RDONLY` - открыть файл только для чтения;
  + `O_WRONLY` - открыть файл только для записи;
  + `O_RDWR` - открыть файл для чтения и записи;
+ *Флаги создания файла* - управляют поведением вызова; НЕ могут быть извлечены или изменены;
  + `O_CLOEXEC` - установить флаг файлового дескриптора close-on-exec `FD_CLOEXEC`;
  + `O_CREAT` - создать новый файл, если он не существует; требует обязательного наличия аргумента вызова `mode`;
  + `O_DIRECTORY` - путевое имя `pathname` должно указывать на *каталог*;
  + `O_EXCL` - указывается совместно с `O_CREAT`; создать новый файл либо вернуть ошибку, если он уже существует (*эксклюзивное создание файла*);
  + `O_LARGEFILE` - используется в 32-разрядных системах для открытия больших файлов, по размеру превышающих 2 Гбайта;
  + `O_NOCTTY` - запретить терминалу под путевым именем `pathname` становиться **управляющим терминалом** данного процесса;
  + `O_NOFOLLOW` - не разыменовывать символьные ссылки;
  + `O_TRUNC` - очистить открываемый файл;
+ *Флаги состояния файла* - впоследствии могут извлечены и изменены:
  + `O_APPEND` - перевести *указатель файла (смещение)* в его конец;
  + `O_NONBLOCK` - открыть файл в *неблокируемом режиме*: если операция ввода-вывода над файлом не может *мгновенно* завершиться *полностью*, то она либо целиком отменяется, возвращая синонимичные значения `EAGAIN` или `EWOULDBLOCK` в переменной `errno`, либо выполняется частично, возвращая реально обработанное количество байт;
  + `O_ASYNC` - часть механизма *ввода-вывода на основе сигналов*; отправлять процессу *сигнал*, когда указанный дескриптор становится доступен для выполнения ввода-вывода; может быть установлен только вызовом `fcntl(F_SETFL)`;
  + `O_DIRECT` - выполнять операции ввода-вывода в обход *дисковых буферов ядра*;
  + `O_SYNC` - выполнять операции ввода-вывода в *синхронном режиме*;
  + `O_DSYNC` - выполнять операции синхронного ввода-вывода с *сохранением целостности данных*;
  + `O_NOATIME` - не обновлять время последнего обращения к файлу при его чтении; *действующий UID* процесса должен соответствовать владельцу файла, либо процесс должен быть *привилегированным* (`CAP_FOWNER`).

---

```C
ssize_t read(
    int fd, 
    void *buffer, 
    size_t count);
```

Считывает из указанного фала максимально `count` байт в заранее выделенный буфер `buffer`. В случае успеха возвращает число *реально прочитанных* байт, которое может оказаться меньше указанного максимального. Попытка чтения за текущим концом файла вернёт 0 байт - данные отсутствуют.

---

```C
ssize_t write(
    int fd, 
    const void *buffer, 
    size_t count);
```

Записывает в указанный файл максимально `count` байт, хранящихся в буфере `buffer`. В случае успеха возвращает число *реально записанных* байт, которое может оказаться меньше указанного максимального. Завершение данного вызова не гарантирует перенос данных на устройство, поскольку ядро выполняет буферизацию дискового ввода-вывода.

---

```C
off_t lseek(int fd, off_t offset, int whence);
```

Сдвигает файловый указатель на `offset` байт относительно позиции `whence`. В случае успеха возвращает новое полученное значение файлового смещения.

Аргумент `whence` принимает следующие значения:

+ `SEEK_SET` - отправной точкой служит начало файла (нулевая позиция);
+ `SEEK_CUR` - отправной точкой служит текущее положение файлового указателя;
+ `SEEK_END` - отправной точкой служит позиция, *следующая за последним байтом файла*;

Аргумент `offset` является целым числом со знаком: нулевое значение просто вернет текущее смещение, а отрицательное заставит указатель передвинуться в противоположном направлении, однако *выходить за начало файла ЗАПРЕЩЕНО*.

Зачастую данный вызов применяется к обыкновенным файлам данных на диске - он не может быть вызван над *FIFO*, *сокетом* и *терминалом*. Файловое смещение - это сущность ядра, и его изменение не требует физического доступа к устройству хранения.

---

```C
int close(int fd);
```

Закрывает открытый файловый дескриптор, высвобождая его для повторного использования процессом. Завершение процесса также приводит к автоматическому закрытию всех его файловых дескрипторов.

---

```C
int truncate(const char *pathname, off_t length);

int ftruncate(int fd, off_t length);
```

Устанавливают для файла, заданного через путевое имя `pathname` или дескриптор `fd`, новый размер `length`. Если файл *урезается*, то избыточные данные теряются. Если файл *увеличивается* в размере, то добавляются нулевые байты, либо образуется файловая дыра. При выполнении данного вызова к файлу применяются стандартные проверки режима и прав доступа.

---

```C
int fcntl(int fd, int cmd, ...);
```

Позволяет извлечь либо установить флаги *режима доступа* и *состояния* указанного файлового дескриптора. Аргумента `cmd` определяет выполняемое действие и принимает значения `F_GETFL` или `F_SETFL`. При установке флага(ов) вызов принимает дополнительный содержащий их параметр.

---

```C
int ioctl(int fd, int request, ... /* argp */);
```

Вызов общего назначения, позволяющий выполнять над указанным файлом или устройством операции, выходящие за пределы описанной универсальной модели. Аргумент `request`, обозначающий совершаемую операцию, обычно сопровождается набором её входных параметров `argp` любого требуемого типа.

## 2.2. Дополнительные операции ввода-вывода

```C
ssize_t pread(
    int fd, 
    void *buf, 
    size_t count, 
    off_t offset);

ssize_t pwrite(
    int fd, 
    const void *buf, 
    size_t count, 
    off_t offset);
```

Являются аналогами стандартных вызовов, однако осуществляют ввод-вывод с заданного смещения `offset` от начала файла, а не с текущей позиции файлового указателя. *НЕ изменяют* значение *файлового смещения*, содержащее в общесистемной дескрипции файла. Тип файла, над которым выполняются данные вызовы, должен поддерживать произвольную установку файлового смещения.

---

```C
ssize_t readv(
    int fd, 
    const struct iovec *iov, 
    int iovcnt);

ssize_t writev(
    int fd, 
    const struct iovec *iov, 
    int iovcnt);
```

Осуществляют *фрагментированный ввод-вывод (scatter-gather IO)*: считывают или записывают непрерывную последовательность байтов файла в `iovcnt` буферов в порядке их следования в наборе `iov`. Поскольку данные вызовы совершаются *атомарно*, то *любые* операции ввода-вывода над указанным файлом в других процессах или потоках не могут нарушить непрерывность обрабатываемой последовательности данных.

---

```C
ssize_t preadv(
    int fd, 
    const struct iovec *iov, 
    int iovcnt, 
    off_t offset);

ssize_t pwritev(
    int fd, 
    const struct iovec *iov, 
    int iovcnt, 
    off_t offset);
```

Фрагментированный ввод-вывод по заданному смещению - являются комбинацией описанных выше вызовов.

## 2.3. Дублирование файловых дескрипторов

```C
int dup(int oldfd);
```

Создает дубликат исходного дескриптора `oldfd`, указывающий на ту же дескрипцию файла в общесистемной таблице.

---

```C
int dup2(int oldfd, int newfd);
```

Создает дубликат исходного дескриптора `oldfd`, указывающий на ту же дескрипцию файла в общесистемной таблице, присваивая ему номер дескриптора `newfd`. Если `newfd` уже существует, то сначала он будет **закрыт**, причем закрытие и повторное открытие будут выполнены *атомарно*. Если в аргументы вызова передан один и тот же дескриптор, то никаких действий не совершается.

---

```C
int dup3(int oldfd, int newfd, int flags);
```

Аналог вызова `dup2()`, дополнительно позволяющий с помощью значения `O_CLOEXEC` аргумента `flags` сразу установить в результирующем дескрипторе флаг close-on-exec.

## 2.4. Создание временных файлов

Если программе на время работы требуются временные файлы, которые будут уничтожены по её завершении, то она может воспользоваться набором библиотечных функций.

---

```C
int mkstemp(char *template);
```

Создаёт и открывает для чтения/записи, возвращая его дескриптор, файл, шаблон `template` путевого имени которого обязан заканчиваться символьной последовательностью `XXXXXX` - она будет автоматически заменена ядром на строку, придающую имени уникальность. Открываемый файл получает права чтения/записи для владельца, а также флаг `O_EXCL`, гарантирующий эксклюзивный доступ. Обычно сразу после создания файла его запись в файловой системе уничтожают вызовом `unlink()` - он продолжит быть доступен процессу через свой дескриптор и будет окончательно удален при его закрытии.

---

```C
FILE *tmpfile(void);
```

Создаёт и эксклюзивно (`O_EXCL`) открывает для чтения/записи временный файл с уникальным именем, возвращая его *файловый поток* библиотеки stdio языка C. При закрытии он будет автоматически удалён.

# 3. Процессы

**Программа** - файл, содержащий следующую информацию о том, как при его выполнении конструировать *процесс*:

+ **идентификатор двоичного формата** - используется ядром для верной интерпретации содержимого файла программы. Linux применяет формат исполняемых и компонуемых файлов - **Executable and Linking Format (ELF)**;
+ **машинный код** - алгоритм программы;
+ **данные** - числовые и сомвольные константы, указанные в программе при её компиляции;
+ **адрес входа в программу** - местоположение первой инструкции, с которой должно начаться выполнение программы;
+ **таблица имен и переадресации** - определяет имена и расположение функций и переменных в файле программы;
+ **информация о библиотеках и компоновщике** - набор полей, определяющий путевые имена используемых динамических библиотек и компоновщика.

**Процесс** - абстракция, являющаяся совокупностью всех ресурсов системы, выделенных ядром для выполнения данного экземпляра программы. Единственный файл программы служит для построения на его основе множества процессов. Физически *процесс* представляет собой некоторый объем оперативной памяти, содержащий в себе загруженные из файла программы машинные инструкции прикладного алгоритма и необходимые ему переменные (в *пользовательском пространстве памяти* процесса), а также инструкции кода ядра и служебные структуры данных (в *пространстве памяти ядра* процесса), управляющие функционированием данного процесса и его взаимодействием с системой и другими процессами. Инструкциям процесса (как прикладным, так и ядра) для их выполнения периодически выделяется доля времени центрального процессора. Системой накладываются ограничения на каждый тип ресурсов процесса, и она следит за соблюдением лимитов. При завершении процесса все занимаемые им ресурсы освобождаются и становятся доступными другим процессам.

Любой процесс обладает создавшим его **родительским процессом**. Корневым предком всех процессов системы является **процесс `init`**, PID которого равняется `1`. Родителем процессов пользовательских программ являются процессы командных оболочек. Если процесс по некоторой причине **сиротеет**, т.е. его родитель полностью завершает своё выполнение, то его новым родителем напрямую становится процесс `init`.

## 3.1. Идентификаторы процесса

Каждый процесс обладает уникальным идентификатором, позволяющим выделить его среди других процессов и представляющим собой целое положительное число - **process ID (PID)**. Пользовательский процесс минимально может получить идентификатор `300` - меньшие значения занимаются системными процессами. Максимально возможное значение PID в Linux определяется файлом `/proc/sys/kernel/pid_max` и на 64-х разрядной системе составляет $2^{22}$ (около 4 миллионов).

PID процесса `init` равняется `1`.

---

```C
pid_t getpid(void);
```

Возвращает PID процесса, выполнившего данный вызов.

---

```C
pid_t getppid(void);
```

Возвращает **parent PID** - идентификатор родителя данного процесса.

## 3.2. Модель памяти процесса

Пространоство адресов памяти, выделенной процессу, *логически* подразделяется на несколько отдельных *сегментов*:

![сегменты памяти процесса](images/img-3.png)

+ **текстовый сегмент** - машинные инструкции пользовательской программы; доступен *только для чтения*; создаётся с возможностью *совместного использования*, в результате единственный экземпляр кода программы с диска проецируется в память множества процессов;
+ **инициализированные данные** - глобальные и статические переменные, инициализированные в коде программы явным образом;
+ **неинициализированные данные** - глобальные и статические переменные *встроенных типов*, НЕ инициализированные явным образом; система автоматически заполняет данную область 0 при страте процесса;
+ **динамическая память (куча)** - область, из которой в ходе работы программы выделяется память под переменнные; верхнюю границу кучи называют *program break*;
+ **стек** - динамически увеличивающаяся и уменьшающаяся последовательность **стековых кадров (фреймов)**; каждой вызванной на данный момент *функции* соответствует собственный фрейм, содержащий её аргументы, локальные переменные, возвращаемое значение;
+ общая область для **аргументов командной строки** и **переменных окружения**.

Физически память, занимаемая инструкциями и переменными процесса, представляет собой набор блоков фиксированного размера - **страничных кадров (фреймов)**. Однако диапазон доступной процессу памяти НЕ образован реальными адресами оперативной памяти - в Linux используется **механизм управления виртуальной памятью**. Каждому процессу выделяется непрерывное, доступное только ему **виртуальное адресное пространство**, простирающееся от нулевого адреса до $2^{32}$ или $2^{64}$ (определяется разрядностью процессора и операционной системы). Выделение виртуальной памяти аналогично происходит фиксированными блоками, называемыми **страницами**. Во время своей работы процесс оперирует виртуальными адресами, однако в реальности каждая *виртуальная страница* представляется *физическим страничным кадром* - информация о соответствии хранится в  **таблице страниц процесса**, а самим отображением виртуальных адресов в реальные занимается специализированный блок центрального процессора *Paged Memory Management Unit (PMMU)*, содержащий кеш *Translation Lookaside Buffer (TLB)*, ускоряющий данную операцию.

![таблица страниц процесса](images/img-4.png)

В любой момент в *страничных кадрах* НЕ требуется наличие ВСЕХ *виртуальных страниц* процесса - реально располагающийся в оперативной памяти набор называется **резидентным набором**. Неиспользуемые страницы при исчерпании всей физической памяти могут размещаться в зарезервированной области диска - **файле подкачки**. Применение данной техники возможно благодаря тому, что программам присуще *свойство локальности* - они демонстрируют тенденцию обращаться в ближайшем будущем к тем же либо близким адресам памяти, к которым было обращение в недавнем прошлом.

Применение операционной системой механизма виртуальной памяти предоставляет следующие преимущества:

+ *процессы изолированы* друг от друга и от ядра, поскольку через таблицу страниц имеют доступ только к собственным кадрам - это не позволяет им прочитать или испортить чужие данные;
+ при необходимости процессы могут *совместно использовать* одну и ту же *физическую память*: виртуальные страницы каждого будут отображаться на одни и те же физические кадры; наиболее характерные примеры - выполнение разными процессами кода одной программы, либо явное выделение *разделяемой памяти* (средство IPC);
+ возможна реализация гибких *схем защиты памяти*, позволяющих для каждой отдельной страницы указывать список действий, которые данный процес может совершать с данным блоком памяти;
+ используемое программой *виртуальное пространство* может существенно *превышать* доступный *физический объем* - страницы будут загружаться в память и выгружаться из неё по мере необходимости; например, программа СУБД может целиком отобразить файл базы в память - так поступает *MongoDB*.

### 3.2.1. Сегмент стека

В Linux на архитектуре процессоров x86 программный стек располагается в верхней части памяти и растет вниз. Динамическую вершину стека называют **указателем стека**. При вызове функции ей системой автоматически выделяется один **стековый кадр**, содержащий:

+ *аргументы функции*;
+ *локальные переменные*;
+ *возвращаемое значение*;
+ копии значений *регистров процессора*, которые должны быть восстановлены при возврате из функции.

После завершения функции её стековый кадр автоматически удаляется системой простым сдвигом указателя вершины стека.

В реальности любой процесс содержит 2 стека:

+ **пользовательский стек** - используется алгоритмом прикладной программы;
+ **стек ядра** - хранится в *пространстве памяти ядра* и выделяется каждому процессу для выполнения всех действий *системного вызова*.

#### 3.2.1.1. Нелокальный переход - longjump

Совершение *нелокального перехода* представляет собой возврат к выполнению заранее отмеченной инструкции, находящейся за пределами исполняемой в данный момент функции.

---

```C
int setjmp(jmp_buf env);
```

Устанавливает место в коде, к которому впоследствии можно совершить переход из выполняемой на тот момент функции, расположенной на вершине пользовательского стека. Совершение перехода через вызов `longjmp()` для процесса выглядит как повторное возвращение значения из `setjmp()`. Первичную установку цели перехода и его фактическое завершение можно различить по возвращаемому результату `setjump()`: оригинальный вызов завершается со значением `0`, фиктивный - с любым другим значением, указанном в соответствующем аргументе `longjmp()`.

Аргумент `env` является выходным параметром, в котором сохраняется копия состояния процесса на момент вызова. В частности, он содержит указатель вершины стека и значения других регистры процессора. Данная информация будет использована в `longjmp()` для возвращения процесса в требуемое состояние.

---

```C
void longjmp(jmp_buf env, int val);
```

Выполняет нелокальный переходит на инструкцию, отмеченную вызовом `setjmp()`. Результатом данного вызова является сброс состояния процесса до указанного в аргументе `env`. Перезапись указателя вершины стека, в частности, приводит к удалению всех стековых кадров, созданных позднее содержащего в себе цель перехода. Аргумент `val` определяет произвольное ненулевое значение, которое будет возвращено при повторном фиктивном завершении вызова `setjmp()`.

---

Обязательным требованием является возвращение выполнения из `longjmp()` в реально существующий на стеке фрейм - цель перехода должна содержаться в некоторой *внешней* по отношению к инициировавшей переход функции, не завершившей свое выполнение.

Вызов `setjmp()` может присутствовать только в следующих контекстах:

+ цельное управляющее выражение инструкции выбора или итерации (`if`, `switch`, `while` и т.д.);
+ операнд унарного отрицания `!`, являющегося цельным управляющим выражением инструкции выбора или итерации;
+ операнд операции сравнения (`==`, `<` и т.д.) при условии, что второй операнд является целочисленной константой, а сама операция является цельным управляющим выражением инструкции выбора или итерации;
+ отдельный вызов функции, не являющийся частью какого-либо выражения.

Выполнение нелокального перехода может испортить реальные значения локальных переменных функции, содержащей цель перехода, вследствие возникновения конфликта с произведенной компилятором оптимизацией (в частности, изменение порядка следования инструкций). По этой причине такие локальные переменные в программах на языке С должны помечаться ключевым словом `volatile`, явно запрещающим их оптимизацию.

### 3.2.2. Сегмент кучи




### 3.2.3. Аргументы командной строки и переменные окружения

*Аргументы командной строки* наряду с *переменными среды (окружения)* представляют собой средство передачи информации от родительского процесса его дочернему. И те, и другие размещаются в одной области над пользовательским стеком процесса. Максимально допустимый размер данной области определяется ограничением ресурса процесса `RLIMIT_STACK`.

**Аргументы командной строки** представляют из себя массив символьных строк параметров, переданных процессу при запуске его программы в *оболочке*. *Имя программы*, используемое для запуска программы (можно создать ссылки под различным названием на единственный файл программы), всегда является самым первым аргументом. В коде программы на языке С *аргументы командной строки* доступны через аргументы `argc` и `argv` функции `main()`. Также в Linux они могут быть прочитаны из предоставленного каждому процессу файла `/proc/PID/cmdline`.

![аргументы командной строки](images/img-5.png)

Список **переменных среды** - связанный с каждым процессом массив, содержащий строки параметров вида `имя=значение`. В момент создания процесс наследует КОПИЮ *окружения* от своей *оболочки*. Оболочка также предоставляет ряд команд для работы с окружением:

+ `$ export NAME=value` - *навсегда* добавить указанную переменную окружения к среде используемой оболочки; добавленное значение будет в составе среды наследоваться всеми процессами, запускаемыми из данной оболочки впоследствии;
+ `$ NAME=value program` - добавить указанную переменную окружения только к среде процесса, выполняющего заданную программу;
+ `$ unset` - удалить переменную окружения из среды оболочки;
+ `$ printenv` - вывести список переменных окружения в среде оболочки;
+ `$ env` - позволяет запускать процессы, манипулируя их окружением; поддерживает богатый функционал.

В коде программы на языке С *переменные окружения* доступны через глобальную переменную `environ`. Также в Linux они могут быть прочитаны из предоставленного каждому процессу файла `/proc/PID/environ`.

![переменные окружения](images/img-6.png)

Существует удобный библиотечный интерфейс по работе с переменными окружения в коде программы.

---

```C
char *getenv(const char *name);
```

Возвращает значение переменной окружения по её имени. Полученную строку НЕЛЬЗЯ изменять и желательно скопировать в отдельный буфер.

---

```C
int putenv(char *str);
```

Добавляет к среде новую переменную окружения или изменяет значение существующей переменной. Строка с переменной не переносится в сегмент памяти, содержащий окружение - среда просто начинает указывать на переданную строку. По этой причине строка `str` не должна изменяться или завершать свой период жизни.

---

```C
int setenv(
    const char *name, 
    const char *value, 
    int overwrite);
```

Создает в сегменте памяти среды новую переменную окружения с заданным именем и значением. Если аргумент `overwrite` ненулевой, то переменная перезаписывается, если уже существует.

---

```C
int unsetenv(const char *name);
```

Удаляет из среды переменную окружения с заданным именем, очищая занимаемое ей место.

---

```C
int clearenv(void)
```

Обнуляет окружение, присваивая указателю `environ` значение `NULL`.

Поскольку физически не очищает место, занимаемое переменными, то приводит к *утечкам памяти* - альтернативой является явный вызов `unsetenv()` для каждой существующей переменной.

